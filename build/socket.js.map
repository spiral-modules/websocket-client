{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/Channel.ts","webpack:///./lib/eventdispatcher/CallbackRegistry.ts","webpack:///./lib/eventdispatcher/EventsDispatcher.ts","webpack:///./lib/messageCodingUtils.ts","webpack:///./lib/eventdispatcher/events.ts","webpack:///./lib/connection/Connection.ts","webpack:///./lib/transport/TransportConnection.ts","webpack:///./lib/transport/Transport.ts","webpack:///./lib/connection/ConnectionManager.ts","webpack:///./lib/constants.ts","webpack:///./lib/SFSocket.ts","webpack:///./lib/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Channel","socket","this","subscribed","subscriptionCancelled","event","data","console","warn","sendEvent","joinChannel","eventName","callback","subscribe","unsubscribe","leaveChannel","CallbackRegistry","callbacks","channel","push","fn","names","keys","removeCallback","removeAllCallbacks","forEach","filter","existedCallback","isEqualCallback","isEqualChannel","add","remove","channelEvent","variableToCheck","context","length","isChannelCallback","systemSymbols","NamesDict","id","transport","super","bindListeners","send","type","error","sfEvent","cmd","args","JSON","stringify","encodeMessage","close","unbindListeners","listeners","unbind","MESSAGE","message","ERROR","CLOSED","closed","messageEvent","sfSocketEvent","messageData","parse","calcChannelName","topic","resultTopic","symbol","String","SFSocketEventType","payload","decodeMessage","e","emit","closeEvent","code","handleCloseEvent","action","prepareCloseAction","hooks","initialize","self","isInitialized","changeState","INITIALIZED","onClose","state","url","getSocket","setTimeout","onError","onClosed","CONNECTING","onopen","onerror","onclose","onmessage","OPEN","wasClean","reason","undefined","onOpen","onMessage","params","options","useTLS","host","portTLS","port","path","window","WebSocket","socketUrl","connected","onInitialized","connect","result","abort","connection","usingTLS","Boolean","errorCallbacks","buildErrorCallbacks","connectionCallbacks","buildConnectionCallbacks","runner","unavailableTimer","retryTimer","updateState","startConnecting","setUnavailableTimer","disconnectInternally","DISCONNECTED","CONNECTED","abortConnecting","clearUnavailableTimer","setConnection","clearRetryTimer","abandonConnection","delay","Math","round","clearTimeout","UNAVAILABLE","unavailableTimeout","socketEvent","errorEvent","shouldRetry","retryIn","withErrorEmitted","refused","disconnect","unavailable","newState","previousState","defaultConfig","useStorage","CONNECTION_EVENTS","Error","constructorOptions","config","channels","eventsDispatcher","hasStorage","localStorage","channelName","subscribeChannel","channelsDisconnect","err","instances","isReady","activeChannels","getStorage","instance","channelsNames","channelsName","isConnected","channelNames","removedChannel","removeChannel","chanelName","addStorageChannel","removeStorageChannel","values","addChannel","reinstateSubscription","join","storageData","getItem","activeStorageChannels","setStorage","activeStorage","currentData","clearStorage","setItem","removeItem","makeSocketOptions","wsUrl","URL","urlProtocol","protocol","replace","hostname"],"mappings":"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","file":"socket.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { UEventCallback } from './types';\nimport { SFSocket } from './SFSocket';\nimport { ConnectionManagerEventMap } from './connection/ConnectionManager';\n\nexport default class Channel {\n  name: string;\n\n  socket: SFSocket;\n\n  subscribed: boolean;\n\n  subscriptionCancelled: boolean;\n\n  constructor(name: string, socket: SFSocket) {\n    this.name = name;\n    this.socket = socket;\n    this.subscribed = false;\n    this.subscriptionCancelled = false;\n  }\n\n  trigger(event: string, data: string[]) { // TODO\n    if (!this.subscribed) {\n      console.warn('Client event triggered before channel \\'subscription_succeeded\\' event'); // eslint-disable-line no-console\n    }\n    return this.socket.sendEvent(event, data, this.name);\n  }\n\n  disconnect() {\n    this.subscribed = false;\n  }\n\n  join() {\n    if (this.subscribed) return;\n    this.subscriptionCancelled = false;\n    this.subscribed = true;\n    this.socket.joinChannel(this.name);\n  }\n\n  subscribe<K extends keyof ConnectionManagerEventMap>(eventName: K, callback: UEventCallback<ConnectionManagerEventMap, K>) {\n    this.socket.subscribe(eventName, callback, this.name);\n  }\n\n  unsubscribe<K extends keyof ConnectionManagerEventMap>(eventName: K, callback: UEventCallback<ConnectionManagerEventMap, K>) {\n    this.socket.unsubscribe(eventName, callback, this.name);\n  }\n\n  leaveChannel() {\n    this.subscribed = false;\n    this.socket.leaveChannel(this.name);\n  }\n\n  cancelSubscription() {\n    this.subscriptionCancelled = true;\n  }\n\n  reinstateSubscription() {\n    this.subscriptionCancelled = false;\n  }\n}\n","import {\n  ICallback, ICallbackTable, UEventCallback,\n} from '../types';\n\nexport default class CallbackRegistry<EventMap> {\n    callbacks: ICallbackTable<EventMap> = {};\n\n    get<K extends keyof EventMap>(name: K): ICallback[] {\n      const results = this.callbacks[name];\n      return (results || [])!; // TODO: Why TS wants '!' here?\n    }\n\n    add<K extends keyof EventMap>(name: K, callback: UEventCallback<EventMap, K>, channel?: string) {\n      if (!this.callbacks[name]) {\n        this.callbacks[name] = [];\n      }\n        this.callbacks[name]!.push({\n          fn: callback,\n          channel: channel || null,\n        });\n    }\n\n    remove<K extends keyof EventMap>(name: K, callback: UEventCallback<EventMap, K>, channel?: string) {\n      if (!name && !callback && !channel) {\n        this.callbacks = {};\n        return;\n      }\n\n      const names: K[] = name ? [name] : Object.keys(this.callbacks) as K[];\n\n      if (callback || channel) {\n        this.removeCallback(names, callback, channel);\n      } else {\n        this.removeAllCallbacks(names);\n      }\n    }\n\n    private removeCallback<K extends keyof EventMap>(names: K[], callback?: UEventCallback<EventMap, K>, channel?: string) {\n      names.forEach((name) => {\n        const callbacks: Array<ICallback<UEventCallback<EventMap, K>>> = (this.callbacks[name] || [])!; // TODO: Why TS wants '!' here?\n        this.callbacks[name] = callbacks.filter(\n          (existedCallback: ICallback) => {\n            const isEqualCallback = callback && callback === existedCallback.fn;\n            const isEqualChannel = channel && channel === existedCallback.channel;\n            return !isEqualCallback && !isEqualChannel;\n          },\n        );\n      });\n    }\n\n    private removeAllCallbacks<K extends keyof EventMap>(names: K[]) {\n      names.forEach((name) => {\n        delete this.callbacks[name];\n      });\n    }\n}\n","import { UEventCallback, ICallback } from '../types';\nimport CallbackRegistry from './CallbackRegistry';\n\nexport interface EventWithChannel {\n  context: { channel: string }\n}\n\nconst isEventWithChannel = (variableToCheck: any): variableToCheck is EventWithChannel => (\n  variableToCheck && variableToCheck.context\n    && typeof variableToCheck.context.channel === 'string'\n);\n\nexport default class EventsDispatcher<EventMap> {\n  callbacks: CallbackRegistry<EventMap> = new CallbackRegistry<EventMap>();\n\n  bind<K extends keyof EventMap>(eventName: K, callback: UEventCallback<EventMap, K>, channel?: string) {\n    this.callbacks.add(eventName, callback, channel);\n    return this;\n  }\n\n  unbind<K extends keyof EventMap>(eventName: K, callback: UEventCallback<EventMap, K>, channel?: string) {\n    this.callbacks.remove(eventName, callback, channel);\n    return this;\n  }\n\n  emit<K extends keyof EventMap>(eventName: K, event: EventMap[K]) : EventsDispatcher<EventMap> {\n    const callbacks = this.callbacks.get(eventName);\n\n    const channelEvent: string | null = isEventWithChannel(event) ? event.context.channel\n      : null;\n\n    const hasCallbacks = callbacks && callbacks.length > 0;\n\n    if (hasCallbacks) {\n      callbacks.forEach((callback: ICallback) => {\n        const isChannelCallback = callback.channel === channelEvent;\n        const isGlobalCallback = !callback.channel || !channelEvent;\n\n        if (isGlobalCallback || isChannelCallback) {\n          callback.fn(event);\n        }\n      });\n    }\n\n    return this;\n  }\n}\n","import { ISFSocketEvent, SFSocketEventType } from './SFSocket';\n\nconst systemSymbols = ['@'];\n\nexport const decodeMessage = (messageEvent: string): ISFSocketEvent => {\n  if (messageEvent) {\n    const messageData = JSON.parse(messageEvent);\n\n    const calcChannelName = (topic: string) => {\n      let resultTopic = topic;\n\n      systemSymbols.forEach((symbol) => {\n        if (topic && topic[0] === symbol) {\n          resultTopic = '';\n        }\n      });\n\n      return String(resultTopic);\n    };\n\n    return {\n      type: SFSocketEventType.MESSAGE,\n      error: null,\n      data: messageData.payload || null,\n      context: {\n        ...(messageData.topic ? { channel: calcChannelName(messageData.topic) } : {}),\n      },\n    };\n  }\n\n  return {\n    type: SFSocketEventType.ERROR,\n    error: `MessageEvent: ${messageEvent} not contains data property`,\n    data: 'MessageParseError',\n  };\n};\n\nexport const encodeMessage = (event: ISFSocketEvent): string => {\n  const sfEvent = {\n    cmd: event.type,\n    args: event.data,\n  };\n\n  return JSON.stringify(sfEvent);\n};\n\n/**\n * See:\n * 1. https://developer.mozilla.org/en-US/docs/WebSockets/WebSockets_reference/CloseEvent\n */\nexport const prepareCloseAction = (closeEvent: ISFSocketEvent): ISFSocketEvent => {\n  if (!closeEvent.context || !closeEvent.context.code) {\n    console.error('Socket event do not contain close code'); // eslint-disable-line no-console\n\n    return {\n      ...closeEvent,\n      error: 'Connection refused',\n    };\n  }\n\n  if (closeEvent.context.code < 4000) {\n    // ignore 1000 CLOSE_NORMAL, 1001 CLOSE_GOING_AWAY,\n    //        1005 CLOSE_NO_STATUS, 1006 CLOSE_ABNORMAL\n    // ignore 1007...3999\n    // handle 1002 CLOSE_PROTOCOL_ERROR, 1003 CLOSE_UNSUPPORTED,\n    //        1004 CLOSE_TOO_LARGE\n    if (closeEvent.context.code >= 1002 && closeEvent.context.code <= 1004) {\n      return {\n        ...closeEvent,\n        error: 'Socket is unavailable',\n      };\n    }\n  }\n\n  return closeEvent;\n};\n","/**\n * Dictionary of event names used across everywhere\n */\nexport enum NamesDict {\n  CONNECTED= 'connected',\n  MESSAGE='message',\n  CONNECTING='connecting',\n  DISCONNECTED='disconnected',\n  ERROR='error',\n  OPEN='open',\n  INITIALIZED='initialized',\n  CLOSED='closed',\n  UNAVAILABLE='unavailable',\n}\n","import EventsDispatcher from '../eventdispatcher/EventsDispatcher';\nimport { ISFSocketEvent, SFSocketEventType } from '../SFSocket';\nimport TransportConnection from '../transport/TransportConnection';\nimport { decodeMessage, encodeMessage, prepareCloseAction } from '../messageCodingUtils';\nimport { NamesDict } from '../eventdispatcher/events';\n\n/**\n * Lists events that can be emitted by `Connection` class\n */\nexport interface ConnectionEventMap {\n  [NamesDict.CLOSED]: ISFSocketEvent,\n  [NamesDict.ERROR]: ISFSocketEvent,\n  [NamesDict.MESSAGE]: ISFSocketEvent,\n}\n\n\nexport interface EventWithCode {\n  context: { code: string }\n}\n\nconst isEventWithCode = (variableToCheck: any): variableToCheck is EventWithCode => (\n  variableToCheck.context\n    && typeof variableToCheck.context.code !== 'undefined'\n);\n\nexport default class Connection extends EventsDispatcher<ConnectionEventMap> {\n  id: string;\n\n  transport: TransportConnection | null;\n\n  constructor(id : string, transport : TransportConnection) {\n    super();\n    this.id = id;\n    this.transport = transport;\n    this.bindListeners();\n  }\n\n  send(data : string) : boolean {\n    if (!this.transport) return false;\n    return this.transport.send(data);\n  }\n\n  sendEvent(name: string, data: any, channel?: string) : boolean {\n    const event: ISFSocketEvent = {\n      type: name as any, // TODO: That's not really a ISFSocketEvent\n      data,\n      error: null,\n    };\n\n    if (channel) {\n      event.context = { channel };\n    }\n\n    return this.send(encodeMessage(event));\n  }\n\n  close() {\n    if (this.transport) {\n      this.transport.close();\n    }\n  }\n\n  private bindListeners() {\n    const unbindListeners = (listeners: any) => { // TODO\n      if (!this.transport) return;\n      this.transport.unbind(NamesDict.MESSAGE, listeners.message);\n      this.transport.unbind(NamesDict.ERROR, listeners.error);\n      this.transport.unbind(NamesDict.CLOSED, listeners.closed);\n    };\n\n    const listeners = {\n      message: (messageEvent: ISFSocketEvent) => {\n        let sfSocketEvent = null;\n        try {\n          sfSocketEvent = decodeMessage(messageEvent.data!);\n        } catch (e) {\n          this.emit(NamesDict.ERROR, {\n            type: SFSocketEventType.ERROR,\n            error: e,\n            data: JSON.stringify(messageEvent),\n          });\n        }\n\n        if (sfSocketEvent) {\n          if (sfSocketEvent.type === SFSocketEventType.ERROR) {\n            this.emit(NamesDict.ERROR, {\n              type: SFSocketEventType.ERROR,\n              data: sfSocketEvent.data,\n              error: null,\n            });\n          } else {\n            this.emit(NamesDict.MESSAGE, sfSocketEvent);\n          }\n        }\n      },\n      error: (error: ISFSocketEvent) => {\n        this.emit(NamesDict.ERROR, {\n          ...error,\n          type: SFSocketEventType.ERROR,\n          data: null, // TODO: Are these overrides needed? Check what's being sent here\n        });\n      },\n      closed: (closeEvent: ISFSocketEvent) => { // TODO\n        unbindListeners(listeners);\n\n        if (isEventWithCode(closeEvent)) {\n          this.handleCloseEvent(closeEvent);\n        }\n\n        this.transport = null;\n        this.emit(NamesDict.CLOSED, closeEvent);\n      },\n    };\n\n    if (!this.transport) return;\n    this.transport.bind(NamesDict.MESSAGE, listeners.message);\n    this.transport.bind(NamesDict.ERROR, listeners.error);\n    this.transport.bind(NamesDict.CLOSED, listeners.closed);\n  }\n\n  private handleCloseEvent(closeEvent : ISFSocketEvent) {\n    const action = prepareCloseAction(closeEvent);\n\n    if (action.type === SFSocketEventType.CLOSED) {\n      this.emit(NamesDict.CLOSED, action);\n    } else {\n      this.emit(NamesDict.ERROR, action);\n    }\n  }\n}\n","import EventsDispatcher from '../eventdispatcher/EventsDispatcher';\nimport { ISFSocketConfig, ISFSocketEvent, SFSocketEventType } from '../SFSocket';\nimport { NamesDict } from '../eventdispatcher/events';\n\nexport interface ITransportHooks {\n  url: string;\n  isInitialized(): boolean;\n  getSocket(url: string, options?: ISFSocketConfig): WebSocket;\n}\n\n\n/**\n * Lists events that can be emitted by `TransportConnection` class\n */\nexport interface TransportEventMap {\n  [NamesDict.INITIALIZED]: undefined,\n  [NamesDict.ERROR]: ISFSocketEvent,\n  [NamesDict.MESSAGE]: ISFSocketEvent,\n  [NamesDict.CLOSED]: ISFSocketEvent,\n  [NamesDict.OPEN]: undefined,\n  [NamesDict.CONNECTING]: undefined,\n}\n\nexport default class TransportConnection extends EventsDispatcher<TransportEventMap> {\n  hooks: ITransportHooks;\n\n  name: string;\n\n  state: string;\n\n  socket?: WebSocket;\n\n  initialize: Function;\n\n  constructor(hooks: ITransportHooks, name: string) {\n    super();\n    this.initialize = () => {\n      const self = this;\n\n      if (self.hooks.isInitialized()) {\n        self.changeState(NamesDict.INITIALIZED);\n      } else {\n        self.onClose();\n      }\n    };\n    this.hooks = hooks;\n    this.name = name;\n\n    this.state = 'new';\n  }\n\n  connect() : boolean {\n    if (this.socket || this.state !== 'initialized') {\n      return false;\n    }\n\n    const { url } = this.hooks;\n    try {\n      this.socket = this.hooks.getSocket(url);\n    } catch (e) {\n      // Workaround for MobileSafari bug (see https://gist.github.com/2052006)\n      setTimeout(() => {\n        this.onError(e);\n        this.onClosed({\n          type: SFSocketEventType.ERROR,\n          data: null,\n          error: e,\n          context: {},\n        });\n      });\n      return false;\n    }\n\n    this.bindListeners();\n    this.changeState(NamesDict.CONNECTING);\n    return true;\n  }\n\n  /** Closes the connection.\n   *\n   * @return {Boolean} true if there was a connection to close\n   */\n  close() : boolean {\n    if (this.socket) {\n      this.socket.close();\n      return true;\n    }\n    return false;\n  }\n\n  send(data : any) : boolean { // TODO\n    if (this.state === 'open') {\n      // Workaround for MobileSafari bug (see https://gist.github.com/2052006)\n      setTimeout(() => {\n        if (this.socket) {\n          this.socket.send(data);\n        }\n      });\n      return true;\n    }\n    return false;\n  }\n\n  private unbindListeners() {\n    if (!this.socket) return;\n    this.socket.onopen = null;\n    this.socket.onerror = null;\n    this.socket.onclose = null;\n    this.socket.onmessage = null;\n  }\n\n\n  private onOpen() {\n    this.changeState(NamesDict.OPEN);\n    if (!this.socket) return;\n    this.socket.onopen = null;\n  }\n\n  private onError(error?: string) {\n    this.emit(NamesDict.ERROR, {\n      type: SFSocketEventType.ERROR,\n      error: error || 'websocket connection error',\n      data: null,\n    });\n  }\n\n  private onClose(closeEvent?: CloseEvent) {\n    if (closeEvent) {\n      this.onClosed({\n        type: closeEvent.wasClean ? SFSocketEventType.CLOSED : SFSocketEventType.ERROR,\n        data: closeEvent.wasClean ? closeEvent.reason : null,\n        error: closeEvent.wasClean ? null : closeEvent.reason,\n        context: {\n          code: closeEvent.code,\n        },\n      });\n    } else {\n      this.onClosed({\n        type: SFSocketEventType.CLOSED,\n        data: null,\n        error: 'Closed for unknown reason',\n        context: {},\n      });\n    }\n    this.unbindListeners();\n    this.socket = undefined;\n  }\n\n  private onMessage(message: MessageEvent) {\n    this.emit(NamesDict.MESSAGE, {\n      type: SFSocketEventType.MESSAGE,\n      data: typeof message.data === 'string' ? message.data : JSON.stringify(message.data),\n      error: null,\n    });\n  }\n\n  private bindListeners() {\n    if (!this.socket) return;\n    this.socket.onopen = () => {\n      this.onOpen();\n    };\n    this.socket.onerror = () => {\n      this.onError();\n    };\n    this.socket.onclose = (closeEvent: CloseEvent) => {\n      this.onClose(closeEvent);\n    };\n    this.socket.onmessage = (message: MessageEvent) => {\n      this.onMessage(message);\n    };\n  }\n\n  private changeState(state: NamesDict.OPEN | NamesDict.CONNECTING | NamesDict.INITIALIZED) {\n    this.state = state;\n    this.emit(state, undefined);\n  }\n\n  private onClosed(params: ISFSocketEvent) {\n    this.state = NamesDict.CLOSED;\n    this.emit(NamesDict.CLOSED, params);\n  }\n}\n","import { UndescribedCallbackFunction } from '../types';\nimport Connection from '../connection/Connection';\nimport TransportConnection, { ITransportHooks } from './TransportConnection';\nimport { ISFSocketConfig } from '../SFSocket';\nimport { NamesDict } from '../eventdispatcher/events';\n\nexport interface IRunner {\n  abort: () => void;\n}\n\nexport interface ITransport {\n  connect(callback: UndescribedCallbackFunction): IRunner;\n}\n\nexport default class Transport implements ITransport {\n  hooks: ITransportHooks;\n\n  name: string;\n\n  options: ISFSocketConfig;\n\n  constructor(name: string, options: ISFSocketConfig) {\n    this.options = options || {};\n\n    const scheme = `ws${options.useTLS ? 's' : ''}`;\n    const host = options.useTLS ? (`${options.host}:${options.portTLS}`) : (`${options.host}:${options.port}`);\n\n    const url = `${scheme}://${host}/${options.path}`;\n\n    this.hooks = {\n      url,\n      isInitialized() {\n        return !!window.WebSocket;\n      },\n      getSocket(socketUrl) {\n        return new WebSocket(socketUrl);\n      },\n    };\n    this.name = name;\n  }\n\n  connect(callback: UndescribedCallbackFunction) {\n    let connected = false;\n\n    const transport = new TransportConnection(\n      this.hooks, this.name,\n    );\n\n    const onInitialized = () => {\n      transport.unbind(NamesDict.INITIALIZED, onInitialized);\n      transport.connect();\n    };\n\n    const unbindListeners = () => {\n      transport.unbind(NamesDict.INITIALIZED, onInitialized);\n      // eslint-disable-next-line no-use-before-define\n      transport.unbind(NamesDict.OPEN, onOpen);\n      // eslint-disable-next-line no-use-before-define\n      transport.unbind(NamesDict.ERROR, onError);\n      // eslint-disable-next-line no-use-before-define\n      transport.unbind(NamesDict.CLOSED, onClosed);\n    };\n\n    const onOpen = () => {\n      connected = true;\n      unbindListeners();\n      const result = new Connection('', transport);\n      callback(null, result);\n    };\n\n    const onError = (error: any) => { // TODO\n      unbindListeners();\n      callback(error);\n    };\n\n    const onClosed = () => {\n      unbindListeners();\n    };\n\n    transport.bind(NamesDict.INITIALIZED, onInitialized);\n    transport.bind(NamesDict.OPEN, onOpen);\n    transport.bind(NamesDict.ERROR, onError);\n    transport.bind(NamesDict.CLOSED, onClosed);\n\n    transport.initialize();\n\n    return {\n      abort: () => {\n        if (connected) {\n          return;\n        }\n        unbindListeners();\n        transport.close();\n      },\n    };\n  }\n}\n","import { UndescribedCallbackFunction } from '../types';\nimport {\n  IAction,\n  IConnectionCallbacks,\n  IErrorCallbacks,\n} from './types';\nimport EventsDispatcher from '../eventdispatcher/EventsDispatcher';\nimport Transport, { IRunner, ITransport } from '../transport/Transport';\nimport Connection from './Connection';\nimport { ISFSocketConfig, ISFSocketEvent, SFSocketEventType } from '../SFSocket';\n\nimport { NamesDict } from '../eventdispatcher/events';\n\nexport type ConnectionState = 'initialized'\n    | NamesDict.UNAVAILABLE\n    | NamesDict.CONNECTING\n    | NamesDict.CONNECTED\n    | NamesDict.DISCONNECTED;\n\nexport interface ConnectionManagerEventMap {\n    [NamesDict.CONNECTING]: ISFSocketEvent,\n    [NamesDict.DISCONNECTED]: undefined,\n    [NamesDict.CONNECTED]: undefined,\n    [NamesDict.ERROR]: ISFSocketEvent,\n    [NamesDict.MESSAGE]: ISFSocketEvent,\n    [NamesDict.CLOSED]: ISFSocketEvent,\n    [NamesDict.UNAVAILABLE]: undefined,\n}\n\nexport default class ConnectionManager extends EventsDispatcher<ConnectionManagerEventMap> {\n    options: ISFSocketConfig;\n\n    state: ConnectionState;\n\n    connection: Connection | null;\n\n    usingTLS: boolean;\n\n    unavailableTimer: number;\n\n    retryTimer: number;\n\n    transport: ITransport;\n\n    runner: IRunner | null;\n\n    errorCallbacks: IErrorCallbacks;\n\n    connectionCallbacks: IConnectionCallbacks;\n\n    constructor(options: ISFSocketConfig) {\n      super();\n      this.options = options || {};\n      this.state = 'initialized';\n      this.connection = null;\n      this.usingTLS = Boolean(options.useTLS);\n\n      this.errorCallbacks = this.buildErrorCallbacks();\n      this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);\n\n      this.transport = new Transport(\n        'ws',\n        options,\n      );\n      this.runner = null;\n\n      this.unavailableTimer = 0;\n      this.retryTimer = 0;\n    }\n\n    connect() {\n      if (this.connection || this.runner) {\n        return;\n      }\n      this.updateState(NamesDict.CONNECTING);\n      this.startConnecting();\n      this.setUnavailableTimer();\n    }\n\n    send(data: string) {\n      if (this.connection) {\n        return this.connection.send(data);\n      }\n      return false;\n    }\n\n    sendEvent(name: string, data: string[], channel?: string) {\n      if (this.connection) {\n        return this.connection.sendEvent(name, data, channel);\n      }\n      return false;\n    }\n\n    disconnect() {\n      this.disconnectInternally();\n      this.updateState(NamesDict.DISCONNECTED);\n    }\n\n    public isConnected() {\n      return this.state === NamesDict.CONNECTED;\n    }\n\n    private startConnecting() {\n      const callback: UndescribedCallbackFunction = (error: Error | undefined | null, connection: Connection) => { // TODO\n        if (error) {\n          this.runner = this.transport.connect(callback);\n        } else {\n          this.abortConnecting();\n\n          this.clearUnavailableTimer();\n          this.setConnection(connection);\n          this.updateState(NamesDict.CONNECTED);\n        }\n      };\n      this.runner = this.transport.connect(callback);\n    }\n\n    private abortConnecting() {\n      if (this.runner) {\n        this.runner.abort();\n        this.runner = null;\n      }\n    }\n\n    private disconnectInternally() {\n      this.abortConnecting();\n      this.clearRetryTimer();\n      this.clearUnavailableTimer();\n      if (this.connection) {\n        const connection = this.abandonConnection();\n        if (connection) connection.close();\n      }\n    }\n\n    private retryIn(delay: number) {\n      if (delay > 0) {\n        this.emit(NamesDict.CONNECTING, {\n          type: SFSocketEventType.CONNECTING,\n          data: String(Math.round(delay / 1000)),\n          error: null,\n        });\n      }\n      this.retryTimer = setTimeout(() => {\n        this.disconnectInternally();\n        this.connect();\n      }, delay || 0);\n    }\n\n    private clearRetryTimer() {\n      if (this.retryTimer) {\n        if (this.retryTimer) {\n          clearTimeout(this.retryTimer);\n        }\n        this.retryTimer = 0;\n      }\n    }\n\n    private setUnavailableTimer() {\n      this.unavailableTimer = setTimeout(\n        () => {\n          this.updateState(NamesDict.UNAVAILABLE);\n        },\n        this.options.unavailableTimeout,\n      );\n    }\n\n    private clearUnavailableTimer() {\n      if (this.unavailableTimer) {\n        clearTimeout(this.unavailableTimer);\n      }\n      this.unavailableTimer = 0;\n    }\n\n    private buildConnectionCallbacks(errorCallbacks: IErrorCallbacks): IConnectionCallbacks {\n      return {\n        ...errorCallbacks,\n        message: (socketEvent: ISFSocketEvent) => {\n          // includes pong messages from server\n          this.emit(NamesDict.MESSAGE, socketEvent);\n        },\n        error: (errorEvent: ISFSocketEvent) => {\n          // just emit error to user - socket will already be closed by browser\n          this.emit(NamesDict.ERROR, errorEvent);\n        },\n        closed: (closeEvent: ISFSocketEvent) => {\n          this.abandonConnection();\n          if (this.shouldRetry()) {\n            this.retryIn(1000);\n          }\n          this.emit(NamesDict.CLOSED, closeEvent);\n        },\n      };\n    }\n\n    private buildErrorCallbacks(): IErrorCallbacks {\n      const withErrorEmitted = (callback: UndescribedCallbackFunction) => (result: IAction) => {\n        if (result.error) {\n          this.emit(NamesDict.ERROR, {\n            type: SFSocketEventType.ERROR,\n            data: null,\n            error: result.error,\n          });\n        }\n        callback(result);\n      };\n\n      return {\n        refused: withErrorEmitted(() => {\n          this.disconnect();\n        }),\n        unavailable: withErrorEmitted(() => {\n          this.retryIn(1000);\n        }),\n      };\n    }\n\n    private setConnection(connection: Connection | null) {\n      this.connection = connection;\n      if (!this.connection) {\n        return;\n      }\n      this.connection.bind(NamesDict.MESSAGE, this.connectionCallbacks.message);\n      this.connection.bind(NamesDict.ERROR, this.connectionCallbacks.error);\n      this.connection.bind(NamesDict.CLOSED, this.connectionCallbacks.closed);\n    }\n\n    private abandonConnection() {\n      if (!this.connection) {\n        return null;\n      }\n      this.connection.unbind(NamesDict.MESSAGE, this.connectionCallbacks.message);\n      this.connection.unbind(NamesDict.ERROR, this.connectionCallbacks.error);\n      this.connection.unbind(NamesDict.CLOSED, this.connectionCallbacks.closed);\n\n      const { connection } = this;\n      this.connection = null;\n\n      return connection;\n    }\n\n    private updateState(newState: NamesDict.UNAVAILABLE\n        | NamesDict.CONNECTING\n        | NamesDict.CONNECTED\n        | NamesDict.DISCONNECTED) {\n      const previousState = this.state;\n      this.state = newState;\n      if (previousState !== newState) {\n        this.emit(newState, undefined);\n      }\n    }\n\n    private shouldRetry(): boolean {\n      return this.state === NamesDict.CONNECTING || this.state === NamesDict.CONNECTED;\n    }\n}\n","import { ISFSocketConfig } from './SFSocket';\n\nexport const defaultConfig: ISFSocketConfig = {\n  host: '',\n  port: 80,\n  portTLS: 443,\n  path: '',\n  unavailableTimeout: 10000,\n  useTLS: false,\n  useStorage: false,\n};\n\nexport const STORAGE_KEY = 'sfsocket_storage';\n","import { UEventCallback } from './types';\nimport Channel from './Channel';\nimport ConnectionManager, { ConnectionManagerEventMap } from './connection/ConnectionManager';\nimport { defaultConfig, STORAGE_KEY } from './constants';\nimport { NamesDict } from './eventdispatcher/events';\nimport EventsDispatcher from './eventdispatcher/EventsDispatcher';\n\nconst CONNECTION_EVENTS = {\n  JOIN: 'join',\n  LEAVE: 'leave',\n};\n\nexport interface IChannels {\n  [name: string]: Channel;\n}\n\n// TODO: why do we even need 'sfSocket' prefix and not just reuse type\nexport enum SFSocketEventType {\n  CONNECTING='sfSocket:connecting',\n  MESSAGE='sfSocket:message',\n  ERROR='sfSocket:error',\n  CLOSED='sfSocket:closed',\n}\n\n\nexport interface ISFSocketConfig {\n  host: string,\n  port: string | number;\n  portTLS?: string | number;\n  path: string;\n  unavailableTimeout?: number;\n  useTLS?: boolean;\n  useStorage?: boolean;\n}\n\nexport interface ISFSocketEvent {\n  type: SFSocketEventType,\n  data: string | null,\n  error: string | null,\n  context?: {\n    channel?: string,\n    code?: string | number,\n  } | null\n}\n\nexport interface SFSocketEventMap {\n  [NamesDict.MESSAGE]: ISFSocketEvent\n}\n\nexport class SFSocket {\n  static instances: SFSocket[] = [];\n\n  static isReady: boolean = false;\n\n  static ready() {\n    SFSocket.isReady = true;\n\n    SFSocket.instances.forEach((instance) => {\n      instance.connect();\n    });\n  }\n\n  config: ISFSocketConfig;\n\n  channels: IChannels;\n\n  eventsDispatcher: EventsDispatcher<SFSocketEventMap>;\n\n  connection: ConnectionManager;\n\n  hasStorage: boolean;\n\n  constructor(options?: ISFSocketConfig) {\n    if (!options || typeof options !== 'object') {\n      throw new Error('sfSocket options should be an object');\n    }\n\n    const constructorOptions = options || {};\n\n    this.config = {\n      ...defaultConfig,\n      ...constructorOptions,\n    };\n\n    this.channels = {};\n    this.eventsDispatcher = new EventsDispatcher();\n\n    this.hasStorage = Boolean(this.config.useStorage && window && window.localStorage);\n\n    this.connection = new ConnectionManager(this.config);\n\n    this.connection.bind(NamesDict.CONNECTED, () => {\n      Object.keys(this.channels).forEach((channelName) => {\n        this.subscribeChannel(channelName);\n      });\n    });\n\n    this.connection.bind(NamesDict.MESSAGE, (event: any) => {\n      this.eventsDispatcher.emit(NamesDict.MESSAGE, event); // TODO: Why do we need eventDispatcher if it only consumes message event\n    });\n\n    this.connection.bind(NamesDict.CONNECTING, () => {\n      this.channelsDisconnect();\n    });\n\n    this.connection.bind(NamesDict.DISCONNECTED, () => {\n      this.channelsDisconnect();\n    });\n\n    this.connection.bind(NamesDict.ERROR, (err: ISFSocketEvent) => {\n      console.error(err); // eslint-disable-line no-console\n    });\n\n    SFSocket.instances.push(this);\n\n    if (SFSocket.isReady) {\n      this.connect();\n    }\n\n    if (this.hasStorage) {\n      const activeChannels: string[] = this.getStorage();\n\n      if (activeChannels) {\n        activeChannels.forEach((channelName) => {\n          this.subscribeChannel(channelName);\n        });\n      }\n    }\n  }\n\n  connect() {\n    this.connection.connect();\n  }\n\n  disconnect() {\n    this.connection.disconnect();\n  }\n\n  // connections\n  sendEvent(eventName: string, data: string[], channel?: string) {\n    return this.connection.sendEvent(eventName, data, channel);\n  }\n\n  join(data: string[]) {\n    return this.sendEvent(CONNECTION_EVENTS.JOIN, data);\n  }\n\n  leave(data: string[]) {\n    return this.sendEvent(CONNECTION_EVENTS.LEAVE, data);\n  }\n\n  listen(channelsNames: string[]) {\n    channelsNames.forEach((channelsName) => {\n      if (this.connection.isConnected()) {\n        this.joinChannel(channelsName);\n      } else {\n        this.subscribeChannel(channelsName);\n      }\n    });\n  }\n\n  stopListen(channelNames: string[]) {\n    channelNames.forEach((channelName) => {\n      const removedChannel = this.removeChannel(channelName);\n      if (removedChannel && this.connection.isConnected()) {\n        removedChannel.leaveChannel();\n      }\n    });\n  }\n\n  // TODO: what was that TODO about? Test if works and remove\n  subscribe<K extends keyof ConnectionManagerEventMap>(eventName: K, callback: UEventCallback<ConnectionManagerEventMap, K>, channel?: string) {\n    return this.connection.bind(eventName, callback, channel);\n  }\n\n  // TODO: what was that TODO about? Test if works and remove\n  unsubscribe<K extends keyof ConnectionManagerEventMap>(eventName: K, callback: UEventCallback<ConnectionManagerEventMap, K>, channel?: string) {\n    return this.connection.unbind(eventName, callback, channel);\n  }\n\n  // channels\n  channel(channelName: string): Channel {\n    return this.subscribeChannel(channelName);\n  }\n\n  addChannel(name : string, socket : SFSocket) {\n    if (!this.channels[name]) {\n      this.channels[name] = new Channel(name, socket);\n    }\n    return this.channels[name];\n  }\n\n  joinChannel(chanelName: string) {\n    this.addStorageChannel(chanelName);\n    return this.sendEvent(CONNECTION_EVENTS.JOIN, [chanelName]);\n  }\n\n  leaveChannel(chanelName: string) {\n    this.removeStorageChannel(chanelName);\n    return this.sendEvent(CONNECTION_EVENTS.LEAVE, [chanelName]);\n  }\n\n  findChannel(name: string): Channel {\n    return this.channels[name];\n  }\n\n  private removeChannel(name : string) {\n    const channel = this.channels[name];\n    delete this.channels[name];\n    return channel;\n  }\n\n  private channelsDisconnect() {\n    Object.values(this.channels).forEach((channel: Channel) => channel.disconnect());\n  }\n\n  private subscribeChannel(channelName: string) {\n    const channel = this.addChannel(channelName, this);\n\n    if (channel.subscriptionCancelled) {\n      channel.reinstateSubscription();\n    } else if (this.connection.isConnected()) {\n      channel.join();\n    }\n    return channel;\n  }\n\n  // storage\n  getStorage() {\n    if (this.hasStorage) {\n      const storageData = window.localStorage.getItem(STORAGE_KEY);\n\n      return storageData ? JSON.parse(storageData) : null;\n    }\n\n    return null;\n  }\n\n  addStorageChannel(channelName: string) {\n    if (this.hasStorage) {\n      const activeStorageChannels = this.getStorage();\n\n      if (activeStorageChannels) { // remove older records\n        const activeChannels = activeStorageChannels.filter((channel: string) => channel !== channelName); // eslint-disable-line max-len\n\n        activeChannels.push(channelName);\n\n        this.setStorage(activeChannels);\n      } else {\n        this.setStorage([channelName]);\n      }\n    }\n  }\n\n  removeStorageChannel(channelName: string) {\n    if (this.hasStorage) {\n      const activeStorage = this.getStorage();\n\n      if (activeStorage) {\n        const currentData = activeStorage.filter((channel: string) => channel !== channelName);\n\n        if (currentData.length) {\n          this.setStorage(currentData);\n        } else {\n          this.clearStorage();\n        }\n      }\n    }\n  }\n\n  setStorage(args: string[]) {\n    if (this.hasStorage) {\n      return window.localStorage.setItem(STORAGE_KEY, JSON.stringify(args));\n    }\n\n    return null;\n  }\n\n  clearStorage() {\n    if (this.hasStorage) {\n      return window.localStorage.removeItem(STORAGE_KEY);\n    }\n\n    return null;\n  }\n}\n","import { SFSocket } from './SFSocket';\n\nconst makeSocketOptions = (wsUrl: string) => {\n  const url = new URL(wsUrl);\n  const urlProtocol = url.protocol ? url.protocol.replace(':', '') : null;\n\n  if (url.hostname && url.port && urlProtocol) {\n    return {\n      host: url.hostname, // host: 'localhost',\n      port: url.port, // port: '8080',\n      path: urlProtocol, // path: 'ws',\n    };\n  }\n\n  return null;\n};\n\n\nexport { SFSocket, makeSocketOptions };\nexport default SFSocket;\n"],"sourceRoot":""}