{"version":3,"sources":["webpack://SFSocket/webpack/universalModuleDefinition","webpack://SFSocket/webpack/bootstrap","webpack://SFSocket/./lib/eventdispatcher/events.ts","webpack://SFSocket/./lib/autobind.ts","webpack://SFSocket/./lib/Channel.ts","webpack://SFSocket/./lib/retrystrategy/index.ts","webpack://SFSocket/./lib/constants.ts","webpack://SFSocket/./lib/eventdispatcher/CallbackRegistry.ts","webpack://SFSocket/./lib/eventdispatcher/EventsDispatcher.ts","webpack://SFSocket/./lib/messageCodingUtils.ts","webpack://SFSocket/./lib/connection/Connection.ts","webpack://SFSocket/./lib/transport/TransportConnection.ts","webpack://SFSocket/./lib/transport/Transport.ts","webpack://SFSocket/./lib/SFSocket.ts","webpack://SFSocket/./lib/connection/ConnectionManager.ts","webpack://SFSocket/./lib/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","NamesDict","autobind","target","descriptor","fn","TypeError","definingProperty","configurable","this","boundFn","ChannelStatus","socket","channelStatus","CLOSED","selfName","cMgr","enabled","isConnected","JOINED","startListening","sendJoinCommand","eventName","callback","unbind","LEAVING","sendLeave","stopListening","channels","indexOf","ERROR","JOINING","sendJoin","DISCONNECTED","onDisconnect","CHANNEL_JOIN_FAILED","onJoinFailed","CHANNEL_JOINED","onJoin","CHANNEL_LEFT","onLeft","CONNECTED","onConnect","defaultConfig","host","port","path","unavailableTimeout","retryTimeout","useTLS","retryStrategy","options","retries","delay","multiplier","event","prevState","state","Promise","resolve","retry","undefined","retriesAllowed","retriesDone","newDelay","setTimeout","CallbackRegistry","callbacks","channel","push","names","keys","removeCallback","removeAllCallbacks","forEach","filter","existedCallback","isEqualCallback","isEqualChannel","add","remove","channelEvent","variableToCheck","context","length","isChannelCallback","SystemEvents","SystemTopics","Set","CHANNEL_LEAVE_FAILED","encodeMessage","sfEvent","command","type","topics","payload","JSON","stringify","ConnectionCommands","SystemCommands","JOIN","LEAVE","id","transport","super","bindListeners","data","send","commandName","has","Error","close","unbindListeners","listeners","MESSAGE","message","error","closed","messageEvent","sfSocketEvent","messageData","parse","topic","Array","isArray","SFSocketEventType","decodeMessage","e","emit","toString","closeEvent","code","handleCloseEvent","action","console","prepareCloseAction","hooks","initialize","self","isInitialized","changeState","INITIALIZED","onClose","url","getSocket","onError","onClosed","CONNECTING","onopen","onerror","onclose","onmessage","OPEN","currentTarget","wasClean","reason","onOpen","socketError","onMessage","params","scheme","paramStr","queryParams","entries","map","encodeURIComponent","join","WebSocket","socketUrl","connected","onInitialized","connect","result","abort","connection","errorCallbacks","buildErrorCallbacks","connectionCallbacks","buildConnectionCallbacks","runner","unavailableTimer","retryTimer","updateState","startConnecting","setUnavailableTimer","sendCommand","disconnectInternally","abandonConnection","shouldRetry","retryIn","abortConnecting","clearUnavailableTimer","setConnection","clearRetryTimer","String","Math","round","clearTimeout","UNAVAILABLE","socketEvent","errorEvent","channelJoined","channelJoinFailed","channelLeft","withErrorEmitted","refused","disconnect","unavailable","retryState","newState","previousState","constructorOptions","config","values","err","instances","isReady","instance","cmdName","channelsNames","channelsName","joinChannel","channelNames","channelName","leaveChannel","chanelName","dontJoin","leave","makeSocketOptions","wsUrl","URL","urlProtocol","protocol","replace","hostname"],"mappings":"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","file":"socket.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SFSocket\"] = factory();\n\telse\n\t\troot[\"SFSocket\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * Dictionary of event names used across everywhere\n */\nexport enum NamesDict {\n  CONNECTED= 'connected',\n  MESSAGE='message',\n  CONNECTING='connecting',\n  DISCONNECTED='disconnected',\n  ERROR='error',\n  OPEN='open',\n  INITIALIZED='initialized',\n  CLOSED='closed',\n  UNAVAILABLE='unavailable',\n  CHANNEL_JOINED='channel_joined',\n  CHANNEL_JOIN_FAILED='channel_join_failed',\n  CHANNEL_LEFT='channel_left',\n}\n","/**\n * Return a descriptor removing the value and returning a getter\n * The getter will return a .bind version of the function\n * and memoize the result against a symbol on the instance\n */\nexport function autobind(target: any, key: string | symbol, descriptor: PropertyDescriptor) {\n  let fn = descriptor.value;\n\n  if (typeof fn !== 'function') {\n    throw new TypeError(`@autobind decorator can only be applied to methods not: ${typeof fn}`);\n  }\n\n  // In IE11 calling Object.defineProperty has a side-effect of evaluating the\n  // getter for the property which is being replaced. This causes infinite\n  // recursion and an \"Out of stack space\" error.\n  let definingProperty = false;\n\n  return {\n    configurable: true,\n    get() {\n      // eslint-disable-next-line no-prototype-builtins\n      if (definingProperty || this === target.prototype || this.hasOwnProperty(key)\n                || typeof fn !== 'function') {\n        return fn;\n      }\n\n      const boundFn = fn.bind(this);\n      definingProperty = true;\n      Object.defineProperty(this, key, {\n        configurable: true,\n        get() {\n          return boundFn;\n        },\n        set(value) {\n          fn = value;\n          delete this[key];\n        },\n      });\n      definingProperty = false;\n      return boundFn;\n    },\n    set(value: any) {\n      fn = value;\n    },\n  };\n}\n","import { UEventCallback } from './types';\nimport { SFSocket } from './SFSocket';\nimport ConnectionManager, { ConnectionManagerEventMap } from './connection/ConnectionManager';\nimport { NamesDict } from './eventdispatcher/events';\nimport { autobind } from './autobind';\n\nexport enum ChannelStatus {\n  CLOSED = 'closed', // Connection command not yet sent or connection was interrupted or server closed channel\n  JOINING = 'joining', // Socket sent join command, server has not responded with OK\n  JOINED = 'joined', // Server returned OK for join command\n  LEAVING = 'leaving', // Socket sent leave command\n  ERROR = 'error', // Join command produced an error\n}\n\nexport default class Channel {\n  private readonly selfName: string;\n\n  private channelStatus: ChannelStatus = ChannelStatus.CLOSED;\n\n  private socket: SFSocket;\n\n  private cMgr: ConnectionManager;\n\n  /**\n   * Flag to indicate if channel should be joined\n   */\n  private enabled: boolean;\n\n  constructor(name: string, socket: SFSocket) {\n    this.selfName = name;\n    this.socket = socket;\n    this.cMgr = socket.cMgr;\n    this.enabled = false;\n  }\n\n  get status() {\n    return this.channelStatus;\n  }\n\n  get name() {\n    return this.selfName;\n  }\n\n  /**\n   * Channel is active and working rn\n   */\n  get isActive() {\n    return this.cMgr.isConnected() && this.channelStatus === ChannelStatus.JOINED;\n  }\n\n  join() {\n    if (this.enabled) return;\n    this.enabled = true;\n    this.startListening();\n    if (this.cMgr.isConnected()) {\n      this.sendJoinCommand();\n    }\n  }\n\n  subscribe<K extends keyof ConnectionManagerEventMap>(eventName: K, callback: UEventCallback<ConnectionManagerEventMap, K>) {\n    this.cMgr.bind(eventName, callback, this.name);\n  }\n\n  unsubscribe<K extends keyof ConnectionManagerEventMap>(eventName: K, callback: UEventCallback<ConnectionManagerEventMap, K>) {\n    this.cMgr.unbind(eventName, callback, this.name);\n  }\n\n  leave() {\n    if (this.enabled) {\n      this.enabled = false;\n      this.channelStatus = ChannelStatus.LEAVING;\n      if (this.cMgr.isConnected()) {\n        this.cMgr.sendLeave([this.name]);\n      }\n      this.stopListening();\n    }\n  }\n\n  @autobind\n  private onConnect() {\n    if (this.enabled) { // if should join/re-join\n      this.sendJoinCommand();\n    }\n  }\n\n  @autobind\n  private onDisconnect() {\n    this.channelStatus = ChannelStatus.CLOSED; // Channel has been closed by external event\n  }\n\n  @autobind\n  private onJoin(channels: string[]) {\n    if (channels.indexOf(this.name) >= 0) {\n      this.channelStatus = ChannelStatus.JOINED; // Channel has failed to join\n    }\n  }\n\n  @autobind\n  private onLeft(channels: string[]) {\n    if (channels.indexOf(this.name) >= 0) {\n      this.channelStatus = ChannelStatus.CLOSED; // Channel was left\n    }\n  }\n\n  @autobind\n  private onJoinFailed(channels: string[]) {\n    if (channels.indexOf(this.name) >= 0) {\n      this.channelStatus = ChannelStatus.ERROR; // Failed to join\n    }\n  }\n\n  private sendJoinCommand() {\n    if (this.channelStatus !== ChannelStatus.JOINING) {\n      this.channelStatus = ChannelStatus.JOINING;\n      this.cMgr.sendJoin([this.name]);\n    }\n  }\n\n  private startListening() {\n    this.cMgr.bind(NamesDict.DISCONNECTED, this.onDisconnect);\n    this.cMgr.bind(NamesDict.CHANNEL_JOIN_FAILED, this.onJoinFailed);\n    this.cMgr.bind(NamesDict.CHANNEL_JOINED, this.onJoin);\n    this.cMgr.bind(NamesDict.CHANNEL_LEFT, this.onLeft);\n    this.cMgr.bind(NamesDict.CONNECTED, this.onConnect);\n  }\n\n  private stopListening() {\n    this.cMgr.unbind(NamesDict.DISCONNECTED, this.onDisconnect);\n    this.cMgr.unbind(NamesDict.CHANNEL_JOIN_FAILED, this.onJoinFailed);\n    this.cMgr.unbind(NamesDict.CHANNEL_JOINED, this.onJoin);\n    this.cMgr.unbind(NamesDict.CHANNEL_LEFT, this.onLeft);\n    this.cMgr.unbind(NamesDict.CONNECTED, this.onConnect);\n  }\n}\n","import { ISFSocketEvent } from '../SFSocket';\nimport { RetryStrategy } from '../connection/types';\n\nexport interface IRetryState {\n  delay: number;\n  retry: number;\n}\n\nexport const INFINITE_RETRIES = -1;\n\nexport const delay = async (d: number) => new Promise((resolve) => {\n  setTimeout(resolve, d);\n});\n\nexport const retryStrategy = (\n  options: { retries?: number, delay?: number, multiplier?: number },\n): RetryStrategy => async (event: ISFSocketEvent, prevState?: unknown) => {\n  const state = prevState as (IRetryState | undefined);\n  if (options.retries === INFINITE_RETRIES) {\n    return Promise.resolve({ retry: true, state: undefined });\n  }\n  if (options.retries === 0) {\n    return Promise.resolve({ retry: false, state: undefined });\n  }\n  const multiplier = options.multiplier ?? 1;\n  const retriesAllowed = options.retries ?? 1;\n  const retriesDone = state?.retry ?? 0;\n  const newDelay = (state?.delay) ? (state.delay * multiplier) : (options.delay ?? 0);\n\n  if (retriesDone < retriesAllowed) {\n    await delay(newDelay);\n    return Promise.resolve({ retry: true, state: { delay: newDelay, retry: retriesDone + 1 } });\n  }\n  return Promise.resolve({ retry: true, state: undefined });\n};\n","import { ISFSocketConfig } from './SFSocket';\nimport { retryStrategy } from './retrystrategy';\n\nexport const defaultConfig: ISFSocketConfig = {\n  host: '',\n  port: 80,\n  path: '',\n  unavailableTimeout: 10000,\n  retryTimeout: 10,\n  useTLS: false,\n  retryStrategy: retryStrategy({ retries: 3, delay: 1000, multiplier: 5 }),\n};\n","import {\n  ICallback, ICallbackTable, UEventCallback,\n} from '../types';\n\nexport default class CallbackRegistry<EventMap> {\n  callbacks: ICallbackTable<EventMap> = {};\n\n  get<K extends keyof EventMap>(name: K): ICallback[] {\n    const results = this.callbacks[name];\n    return (results || [])!; // TODO: Why TS wants '!' here?\n  }\n\n  add<K extends keyof EventMap>(name: K, callback: UEventCallback<EventMap, K>, channel?: string) {\n    if (!this.callbacks[name]) {\n      this.callbacks[name] = [];\n    }\n        this.callbacks[name]!.push({\n          fn: callback,\n          channel: channel || null,\n        });\n  }\n\n  remove<K extends keyof EventMap>(name: K, callback?: UEventCallback<EventMap, K>, channel?: string) {\n    if (!name && !callback && !channel) {\n      this.callbacks = {};\n      return;\n    }\n\n    const names: K[] = name ? [name] : Object.keys(this.callbacks) as K[];\n\n    if (callback || channel) {\n      this.removeCallback(names, callback, channel);\n    } else {\n      this.removeAllCallbacks(names);\n    }\n  }\n\n  private removeCallback<K extends keyof EventMap>(names: K[], callback?: UEventCallback<EventMap, K>, channel?: string) {\n    names.forEach((name) => {\n      const callbacks: Array<ICallback<UEventCallback<EventMap, K>>> = (this.callbacks[name] || [])!; // TODO: Why TS wants '!' here?\n      this.callbacks[name] = callbacks.filter(\n        (existedCallback: ICallback) => {\n          const isEqualCallback = callback && callback === existedCallback.fn;\n          const isEqualChannel = channel && channel === existedCallback.channel;\n          return !isEqualCallback && !isEqualChannel;\n        },\n      );\n    });\n  }\n\n  private removeAllCallbacks<K extends keyof EventMap>(names: K[]) {\n    names.forEach((name) => {\n      delete this.callbacks[name];\n    });\n  }\n}\n","import { UEventCallback, ICallback } from '../types';\nimport CallbackRegistry from './CallbackRegistry';\n\nexport interface EventWithChannel {\n  context: { channel: string }\n}\n\nconst isEventWithChannel = (variableToCheck: any): variableToCheck is EventWithChannel => (\n  variableToCheck && variableToCheck.context\n    && typeof variableToCheck.context.channel === 'string'\n);\n\nexport default class EventsDispatcher<EventMap> {\n  callbacks: CallbackRegistry<EventMap> = new CallbackRegistry<EventMap>();\n\n  bind<K extends keyof EventMap>(eventName: K, callback: UEventCallback<EventMap, K>, channel?: string) {\n    this.callbacks.add(eventName, callback, channel);\n    return this;\n  }\n\n  unbind<K extends keyof EventMap>(eventName: K, callback: UEventCallback<EventMap, K>, channel?: string) {\n    this.callbacks.remove(eventName, callback, channel);\n    return this;\n  }\n\n  emit<K extends keyof EventMap>(eventName: K, event: EventMap[K]) : EventsDispatcher<EventMap> {\n    const callbacks = this.callbacks.get(eventName);\n\n    const channelEvent: string | null = isEventWithChannel(event) ? event.context.channel\n      : null;\n\n    const hasCallbacks = callbacks && callbacks.length > 0;\n\n    if (hasCallbacks) {\n      callbacks.forEach((callback: ICallback) => {\n        const isChannelCallback = callback.channel === channelEvent;\n        const isGlobalCallback = !callback.channel || !channelEvent;\n\n        if (isGlobalCallback || isChannelCallback) {\n          callback.fn(event);\n        }\n      });\n    }\n\n    return this;\n  }\n}\n","import { ISFSocketEvent, SFSocketEventType } from './SFSocket';\n\nexport enum SystemEvents {\n    CHANNEL_JOINED = '@join', // server payload is string[] = channel list that were successfully joined\n    CHANNEL_JOIN_FAILED = '#join', // server payload is string[] = channel list that failed to join\n    CHANNEL_LEFT = '@leave', // server payload is string[] = channel list that were successfully left\n    CHANNEL_LEAVE_FAILED = '#leave', // server payload is string[] = channel list that failed to leave\n}\n\nexport const SystemTopics = new Set<string>([\n  SystemEvents.CHANNEL_JOINED,\n  SystemEvents.CHANNEL_JOIN_FAILED,\n  SystemEvents.CHANNEL_LEFT,\n  SystemEvents.CHANNEL_LEAVE_FAILED,\n]);\n\nexport const decodeMessage = (messageEvent: string | null): ISFSocketEvent => {\n  if (messageEvent) {\n    const messageData = JSON.parse(messageEvent);\n    if (SystemTopics.has(messageData.topic)) {\n      if (!messageData.payload && Array.isArray(messageData.payload)) {\n        return {\n          type: SFSocketEventType.ERROR,\n          error: 'WS event system event payload is invalid. Should be a string array',\n          data: 'MessageParseError',\n        };\n      }\n    }\n    switch (messageData.topic) {\n      case SystemEvents.CHANNEL_JOINED:\n        return {\n          type: SFSocketEventType.CHANNEL_JOINED,\n          error: null,\n          data: messageData.payload,\n        };\n      case SystemEvents.CHANNEL_JOIN_FAILED:\n        return {\n          type: SFSocketEventType.CHANNEL_JOIN_FAILED,\n          error: null,\n          data: messageData.payload,\n        };\n      case SystemEvents.CHANNEL_LEFT:\n        return {\n          type: SFSocketEventType.CHANNEL_LEFT,\n          error: null,\n          data: messageData.payload,\n        };\n      case SystemEvents.CHANNEL_LEAVE_FAILED:\n        return {\n          type: SFSocketEventType.CHANNEL_LEAVE_FAILED,\n          error: null,\n          data: messageData.payload,\n        };\n      default:\n        return {\n          type: SFSocketEventType.MESSAGE,\n          error: null,\n          data: messageData.payload || null,\n          context: {\n            ...(messageData.topic ? { channel: messageData.topic } : {}),\n          },\n        };\n    }\n  }\n\n  return {\n    type: SFSocketEventType.ERROR,\n    error: 'MessageEvent has no data property',\n    data: 'MessageParseError',\n  };\n};\n\nexport const encodeMessage = (event: { type: string, payload: any }): string => {\n  const sfEvent = {\n    command: event.type,\n    topics: event.payload,\n  };\n\n  return JSON.stringify(sfEvent);\n};\n\n/**\n * See:\n * 1. https://developer.mozilla.org/en-US/docs/WebSockets/WebSockets_reference/CloseEvent\n */\nexport const prepareCloseAction = (closeEvent: ISFSocketEvent): ISFSocketEvent => {\n  if (!closeEvent.context || !closeEvent.context.code) {\n    console.error('Socket event do not contain close code'); // eslint-disable-line no-console\n\n    return {\n      ...closeEvent,\n      error: 'Connection refused',\n    };\n  }\n\n  if (closeEvent.context.code < 4000) {\n    // ignore 1000 CLOSE_NORMAL, 1001 CLOSE_GOING_AWAY,\n    //        1005 CLOSE_NO_STATUS, 1006 CLOSE_ABNORMAL\n    // ignore 1007...3999\n    // handle 1002 CLOSE_PROTOCOL_ERROR, 1003 CLOSE_UNSUPPORTED,\n    //        1004 CLOSE_TOO_LARGE\n    if (closeEvent.context.code >= 1002 && closeEvent.context.code <= 1004) {\n      return {\n        ...closeEvent,\n        error: 'Socket is unavailable',\n      };\n    }\n  }\n\n  return closeEvent;\n};\n","import EventsDispatcher from '../eventdispatcher/EventsDispatcher';\nimport { ISFSocketEvent, SFSocketEventType } from '../SFSocket';\nimport TransportConnection from '../transport/TransportConnection';\nimport { decodeMessage, encodeMessage, prepareCloseAction } from '../messageCodingUtils';\nimport { NamesDict } from '../eventdispatcher/events';\n\n/**\n * Lists events that can be emitted by `Connection` class\n */\nexport interface ConnectionEventMap {\n  [NamesDict.CLOSED]: ISFSocketEvent,\n  [NamesDict.ERROR]: ISFSocketEvent,\n  [NamesDict.MESSAGE]: ISFSocketEvent,\n  [NamesDict.CHANNEL_JOIN_FAILED]: string[],\n  [NamesDict.CHANNEL_JOINED]: string[],\n  [NamesDict.CHANNEL_LEFT]: string[],\n}\n\nexport enum ConnectionCommands {\n  JOIN = 'join',\n  LEAVE = 'leave',\n}\n\nexport const SystemCommands = new Set<string>([ConnectionCommands.JOIN, ConnectionCommands.LEAVE]);\n\nexport interface EventWithCode {\n  context: { code: string }\n}\n\nconst isEventWithCode = (variableToCheck: any): variableToCheck is EventWithCode => (\n  variableToCheck.context\n    && typeof variableToCheck.context.code !== 'undefined'\n);\n\nexport default class Connection extends EventsDispatcher<ConnectionEventMap> {\n  id: string;\n\n  transport: TransportConnection | null;\n\n  constructor(id : string, transport : TransportConnection) {\n    super();\n    this.id = id;\n    this.transport = transport;\n    this.bindListeners();\n  }\n\n  send(data : string) : boolean {\n    if (!this.transport) return false;\n    return this.transport.send(data);\n  }\n\n  /**\n   * Sends custom command to ws connection\n   * @param commandName - command that has custom handler on server\n   * @param payload - any serializable data\n   */\n  sendCommand(commandName: string, payload: any) : boolean {\n    if (SystemCommands.has(commandName)) {\n      throw new Error(`${commandName} is a reserved command, cant be sent manually`);\n    }\n\n    return this.send(encodeMessage({ type: commandName, payload }));\n  }\n\n  /**\n   * Sends command to join specific channels\n   * @param channels\n   */\n  sendJoin(channels: string[]) {\n    this.send(encodeMessage({\n      type: ConnectionCommands.JOIN,\n      payload: channels,\n    }));\n  }\n\n  sendLeave(channels: string[]) {\n    this.send(encodeMessage({\n      type: ConnectionCommands.LEAVE,\n      payload: channels,\n    }));\n  }\n\n  close() {\n    if (this.transport) {\n      this.transport.close();\n    }\n  }\n\n  private bindListeners() {\n    const unbindListeners = (listeners: any) => { // TODO\n      if (!this.transport) return;\n      this.transport.unbind(NamesDict.MESSAGE, listeners.message);\n      this.transport.unbind(NamesDict.ERROR, listeners.error);\n      this.transport.unbind(NamesDict.CLOSED, listeners.closed);\n    };\n\n    const listeners = {\n      message: (messageEvent: ISFSocketEvent) => {\n        let sfSocketEvent = null;\n        try {\n          sfSocketEvent = decodeMessage(messageEvent.data);\n        } catch (e: any) {\n          this.emit(NamesDict.ERROR, {\n            type: SFSocketEventType.ERROR,\n            error: e.toString(),\n            data: JSON.stringify(messageEvent),\n          });\n        }\n\n        if (sfSocketEvent) {\n          switch (sfSocketEvent.type) {\n            case SFSocketEventType.ERROR:\n              this.emit(NamesDict.ERROR, sfSocketEvent);\n              break;\n            case SFSocketEventType.CHANNEL_JOIN_FAILED:\n              this.emit(NamesDict.CHANNEL_JOIN_FAILED, sfSocketEvent.data as any); // TODO:\n              break;\n            case SFSocketEventType.CHANNEL_JOINED:\n              this.emit(NamesDict.CHANNEL_JOINED, sfSocketEvent.data as any); // TODO:\n              break;\n            case SFSocketEventType.CHANNEL_LEFT:\n              this.emit(NamesDict.CHANNEL_LEFT, sfSocketEvent.data as any); // TODO:\n              break;\n            case SFSocketEventType.CHANNEL_LEAVE_FAILED:\n              this.emit(NamesDict.ERROR, sfSocketEvent);\n              break;\n            default:\n              this.emit(NamesDict.MESSAGE, sfSocketEvent);\n          }\n        }\n      },\n      error: (error: ISFSocketEvent) => {\n        this.emit(NamesDict.ERROR, {\n          ...error,\n          type: SFSocketEventType.ERROR,\n          data: null, // TODO: Are these overrides needed? Check what's being sent here\n        });\n      },\n      closed: (closeEvent: ISFSocketEvent) => { // TODO\n        unbindListeners(listeners);\n\n        if (isEventWithCode(closeEvent)) {\n          this.handleCloseEvent(closeEvent);\n        }\n\n        this.transport = null;\n        this.emit(NamesDict.CLOSED, closeEvent);\n      },\n    };\n\n    if (!this.transport) return;\n    this.transport.bind(NamesDict.MESSAGE, listeners.message);\n    this.transport.bind(NamesDict.ERROR, listeners.error);\n    this.transport.bind(NamesDict.CLOSED, listeners.closed);\n  }\n\n  private handleCloseEvent(closeEvent : ISFSocketEvent) {\n    const action = prepareCloseAction(closeEvent);\n\n    if (action.type === SFSocketEventType.CLOSED) {\n      this.emit(NamesDict.CLOSED, action);\n    } else {\n      this.emit(NamesDict.ERROR, action);\n    }\n  }\n}\n","import EventsDispatcher from '../eventdispatcher/EventsDispatcher';\nimport { ISFSocketConfig, ISFSocketEvent, SFSocketEventType } from '../SFSocket';\nimport { NamesDict } from '../eventdispatcher/events';\n\nexport interface ITransportHooks {\n  url: string;\n\n  isInitialized(): boolean;\n\n  getSocket(url: string, options?: ISFSocketConfig): WebSocket;\n}\n\nconst isEvent = (variableToCheck: any): variableToCheck is Event => (\n  variableToCheck && typeof variableToCheck.type === 'string' && typeof variableToCheck.currentTarget !== 'undefined'\n);\n\n/**\n * Lists events that can be emitted by `TransportConnection` class\n */\nexport interface TransportEventMap {\n  [NamesDict.INITIALIZED]: undefined,\n  [NamesDict.ERROR]: ISFSocketEvent,\n  [NamesDict.MESSAGE]: ISFSocketEvent,\n  [NamesDict.CLOSED]: ISFSocketEvent,\n  [NamesDict.OPEN]: undefined,\n  [NamesDict.CONNECTING]: undefined,\n}\n\nexport default class TransportConnection extends EventsDispatcher<TransportEventMap> {\n  hooks: ITransportHooks;\n\n  name: string;\n\n  state: string;\n\n  socket?: WebSocket;\n\n  initialize: Function;\n\n  constructor(hooks: ITransportHooks, name: string) {\n    super();\n    this.initialize = () => {\n      const self = this;\n\n      if (self.hooks.isInitialized()) {\n        self.changeState(NamesDict.INITIALIZED);\n      } else {\n        self.onClose();\n      }\n    };\n    this.hooks = hooks;\n    this.name = name;\n\n    this.state = 'new';\n  }\n\n  connect(): boolean {\n    if (this.socket || this.state !== 'initialized') {\n      return false;\n    }\n\n    const { url } = this.hooks;\n    try {\n      this.socket = this.hooks.getSocket(url);\n    } catch (e: any) {\n      // Workaround for MobileSafari bug (see https://gist.github.com/2052006)\n      setTimeout(() => {\n        this.onError(e);\n        this.onClosed({\n          type: SFSocketEventType.ERROR,\n          data: e,\n          error: e.toString(),\n          context: {\n            code: 0,\n          },\n        });\n      });\n      return false;\n    }\n\n    this.bindListeners();\n    this.changeState(NamesDict.CONNECTING);\n    return true;\n  }\n\n  /** Closes the connection.\n   *\n   * @return {Boolean} true if there was a connection to close\n   */\n  close(): boolean {\n    if (this.socket) {\n      this.socket.close();\n      return true;\n    }\n    return false;\n  }\n\n  send(data: any): boolean { // TODO\n    if (this.state === 'open') {\n      // Workaround for MobileSafari bug (see https://gist.github.com/2052006)\n      setTimeout(() => {\n        if (this.socket) {\n          this.socket.send(data);\n        }\n      });\n      return true;\n    }\n    return false;\n  }\n\n  private unbindListeners() {\n    if (!this.socket) return;\n    this.socket.onopen = null;\n    this.socket.onerror = null;\n    this.socket.onclose = null;\n    this.socket.onmessage = null;\n  }\n\n  private onOpen() {\n    this.changeState(NamesDict.OPEN);\n    if (!this.socket) return;\n    this.socket.onopen = null;\n  }\n\n  private onError(error?: Event | Error) {\n    if (isEvent(error)) {\n      this.emit(NamesDict.ERROR, {\n        type: SFSocketEventType.ERROR,\n        error: 'Websocket connection error',\n        data: null,\n      });\n    } else {\n      this.emit(NamesDict.ERROR, {\n        type: SFSocketEventType.ERROR,\n        error: error ? error.message : 'Websocket connection error',\n        data: error ? error.name : null,\n      });\n    }\n  }\n\n  private onClose(closeEvent?: CloseEvent) {\n    if (closeEvent) {\n      this.onClosed({\n        type: closeEvent.wasClean ? SFSocketEventType.CLOSED : SFSocketEventType.ERROR,\n        data: closeEvent.wasClean ? closeEvent.reason : null,\n        error: closeEvent.wasClean ? null : closeEvent.reason,\n        context: {\n          code: closeEvent.code,\n        },\n      });\n    } else {\n      this.onClosed({\n        type: SFSocketEventType.ERROR,\n        data: null,\n        error: 'Closed for unknown reason',\n        context: {\n          code: 0,\n        },\n      });\n    }\n    this.unbindListeners();\n    this.socket = undefined;\n  }\n\n  private onMessage(message: MessageEvent) {\n    this.emit(NamesDict.MESSAGE, {\n      type: SFSocketEventType.MESSAGE,\n      data: typeof message.data === 'string' ? message.data : JSON.stringify(message.data),\n      error: null,\n    });\n  }\n\n  private bindListeners() {\n    if (!this.socket) return;\n    this.socket.onopen = () => {\n      this.onOpen();\n    };\n    this.socket.onerror = (socketError: Event) => {\n      this.onError(socketError);\n    };\n    this.socket.onclose = (closeEvent: CloseEvent) => {\n      this.onClose(closeEvent);\n    };\n    this.socket.onmessage = (message: MessageEvent) => {\n      this.onMessage(message);\n    };\n  }\n\n  private changeState(state: NamesDict.OPEN | NamesDict.CONNECTING | NamesDict.INITIALIZED) {\n    this.state = state;\n    this.emit(state, undefined);\n  }\n\n  private onClosed(params: ISFSocketEvent) {\n    this.state = NamesDict.CLOSED;\n    this.emit(NamesDict.CLOSED, params);\n  }\n}\n","import { UndescribedCallbackFunction } from '../types';\nimport Connection from '../connection/Connection';\nimport TransportConnection, { ITransportHooks } from './TransportConnection';\nimport { ISFSocketConfig, ISFSocketEvent } from '../SFSocket';\nimport { NamesDict } from '../eventdispatcher/events';\n\nexport interface IRunner {\n  abort: () => void;\n}\n\nexport interface ITransport {\n  connect(callback: UndescribedCallbackFunction): IRunner;\n}\n\nexport default class Transport implements ITransport {\n  hooks: ITransportHooks;\n\n  name: string;\n\n  options: ISFSocketConfig;\n\n  constructor(name: string, options: ISFSocketConfig) {\n    this.options = options || {};\n\n    const scheme = `ws${options.useTLS ? 's' : ''}`;\n    const host = `${options.host}:${options.port}`;\n    // eslint-disable-next-line max-len\n    const paramStr = options.queryParams ? Object.entries(options.queryParams).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join('&') : null;\n\n    const url = `${scheme}://${host}/${options.path}${paramStr ? (`?${paramStr}`) : ''}`;\n\n    this.hooks = {\n      url,\n      isInitialized() {\n        return !!window.WebSocket;\n      },\n      getSocket(socketUrl) {\n        return new WebSocket(socketUrl);\n      },\n    };\n    this.name = name;\n  }\n\n  connect(callback: UndescribedCallbackFunction) {\n    let connected = false;\n\n    const transport = new TransportConnection(\n      this.hooks, this.name,\n    );\n\n    const onInitialized = () => {\n      transport.unbind(NamesDict.INITIALIZED, onInitialized);\n      transport.connect();\n    };\n\n    const unbindListeners = () => {\n      transport.unbind(NamesDict.INITIALIZED, onInitialized);\n      // eslint-disable-next-line no-use-before-define\n      transport.unbind(NamesDict.OPEN, onOpen);\n      // eslint-disable-next-line no-use-before-define\n      transport.unbind(NamesDict.ERROR, onError);\n      // eslint-disable-next-line no-use-before-define\n      transport.unbind(NamesDict.CLOSED, onClosed);\n    };\n\n    const onOpen = () => {\n      connected = true;\n      unbindListeners();\n      const result = new Connection('', transport);\n      callback(null, result);\n    };\n\n    const onError = () => {\n      // Note errors are bound and handled above\n    };\n\n    const onClosed = (closeEvent: ISFSocketEvent) => {\n      unbindListeners();\n      callback(closeEvent);\n    };\n\n    transport.bind(NamesDict.INITIALIZED, onInitialized);\n    transport.bind(NamesDict.OPEN, onOpen);\n    transport.bind(NamesDict.ERROR, onError);\n    transport.bind(NamesDict.CLOSED, onClosed);\n\n    transport.initialize();\n\n    return {\n      abort: () => {\n        if (connected) {\n          return;\n        }\n        unbindListeners();\n        transport.close();\n      },\n    };\n  }\n}\n","import { UEventCallback } from './types';\nimport Channel from './Channel';\nimport ConnectionManager, { ConnectionManagerEventMap } from './connection/ConnectionManager';\nimport { defaultConfig } from './constants';\nimport { NamesDict } from './eventdispatcher/events';\nimport { RetryStrategy } from './connection/types';\n\nexport interface IChannels {\n  [name: string]: Channel;\n}\n\n// TODO: why do we even need 'sfSocket' prefix and not just reuse type\nexport enum SFSocketEventType {\n  CONNECTING = 'sfSocket:connecting',\n  MESSAGE = 'sfSocket:message',\n  CHANNEL_JOINED = 'channel_joined',\n  CHANNEL_JOIN_FAILED = 'channel_join_failed',\n  CHANNEL_LEFT = 'channel_left',\n  CHANNEL_LEAVE_FAILED = 'channel_leave_failed',\n  ERROR = 'sfSocket:error',\n  CLOSED = 'sfSocket:closed',\n}\n\nexport interface ISFSocketConfig {\n  host: string,\n  port: string | number;\n  path: string;\n  queryParams?: { [key: string]: string };\n  unavailableTimeout?: number;\n  useTLS?: boolean;\n  retryTimeout?: number;\n  // eslint-disable-next-line no-use-before-define\n  retryStrategy?: RetryStrategy;\n}\n\nexport interface ISFSocketEvent {\n  type: SFSocketEventType,\n  data: string | null,\n  error: string | null,\n  context?: {\n    channel?: string,\n    code?: string | number,\n  } | null\n}\n\nexport class SFSocket {\n  // eslint-disable-next-line no-use-before-define\n  static instances: SFSocket[] = [];\n\n  static isReady: boolean = false;\n\n  static ready() {\n    SFSocket.isReady = true;\n\n    SFSocket.instances.forEach((instance) => {\n      instance.connect();\n    });\n  }\n\n  private config: ISFSocketConfig;\n\n  private channels: IChannels = {};\n\n  cMgr: ConnectionManager;\n\n  constructor(options?: ISFSocketConfig) {\n    if (!options || typeof options !== 'object') {\n      throw new Error('sfSocket options should be an object');\n    }\n\n    const constructorOptions = options || {};\n\n    this.config = {\n      ...defaultConfig,\n      ...constructorOptions,\n    };\n\n    this.config.port = constructorOptions.useTLS ? 443 : 80;\n    if (constructorOptions.port) {\n      this.config.port = constructorOptions.port;\n    }\n\n    this.cMgr = new ConnectionManager(this.config);\n\n    this.cMgr.bind(NamesDict.CONNECTED, () => {\n      Object.values(this.channels).forEach((channel) => {\n        channel.join(); // Send join command again on connect\n      });\n    });\n\n    this.cMgr.bind(NamesDict.ERROR, (err: ISFSocketEvent) => {\n      console.error(err); // eslint-disable-line no-console\n    });\n\n    SFSocket.instances.push(this);\n\n    if (SFSocket.isReady) {\n      this.connect();\n    }\n  }\n\n  connect() {\n    this.cMgr.connect();\n  }\n\n  disconnect() {\n    this.cMgr.disconnect();\n  }\n\n  /**\n   * Send custom command to server\n   * @param cmdName - string name of command\n   * @param data - serializable payload for data\n   */\n  sendCommand(cmdName: string, data: any) {\n    return this.cMgr.sendCommand(cmdName, data);\n  }\n\n  joinChannelList(channelsNames: string[]) {\n    channelsNames.forEach((channelsName) => {\n      this.joinChannel(channelsName);\n    });\n  }\n\n  leaveChannelList(channelNames: string[]) {\n    channelNames.forEach((channelName) => {\n      this.leaveChannel(channelName);\n    });\n  }\n\n  /**\n   * Subscribe to event globally\n   * @param eventName\n   * @param callback\n   * @param channel - optional channel to monitor. Note subscribing to channel here is not creating auto-rejoinable channel.\n   * Join channel explicitly to make it auto-rejoinable\n   */\n  subscribe<K extends keyof ConnectionManagerEventMap>(eventName: K, callback: UEventCallback<ConnectionManagerEventMap, K>, channel?: string) {\n    return this.cMgr.bind(eventName, callback, channel);\n  }\n\n  /**\n   * Unsubscribe from event globally\n   * @param eventName\n   * @param callback\n   * @param channel - optional channel to monitor. Note subscribing to channel here is not creating auto-rejoinable channel.\n   * Join channel explicitly to make it auto-rejoinable\n   */\n  unsubscribe<K extends keyof ConnectionManagerEventMap>(eventName: K, callback: UEventCallback<ConnectionManagerEventMap, K>, channel?: string) {\n    return this.cMgr.unbind(eventName, callback, channel);\n  }\n\n  joinChannel(chanelName: string, dontJoin: boolean = false) {\n    if (this.channels[chanelName]) {\n      throw new Error(`Channel ${chanelName} already exists`);\n    }\n    this.channels[chanelName] = new Channel(chanelName, this);\n    if (!dontJoin) {\n      this.channels[chanelName].join();\n    }\n    return this.channels[chanelName];\n  }\n\n  leaveChannel(chanelName: string) {\n    if (!this.channels[chanelName]) {\n      throw new Error(`Channel ${chanelName} does not exist`);\n    }\n    const channel = this.channels[chanelName];\n    channel.leave();\n    delete this.channels[chanelName];\n    return channel;\n  }\n\n  getChannel(name: string): Channel {\n    return this.channels[name];\n  }\n}\n","import { defaultConfig } from '../constants';\nimport { UndescribedCallbackFunction } from '../types';\nimport {\n  IAction,\n  IConnectionCallbacks,\n  IErrorCallbacks,\n} from './types';\nimport EventsDispatcher from '../eventdispatcher/EventsDispatcher';\nimport Transport, { IRunner, ITransport } from '../transport/Transport';\nimport Connection from './Connection';\nimport { ISFSocketConfig, ISFSocketEvent, SFSocketEventType } from '../SFSocket';\n\nimport { NamesDict } from '../eventdispatcher/events';\n\nexport type ConnectionState = 'initialized'\n  | NamesDict.UNAVAILABLE\n  | NamesDict.CONNECTING\n  | NamesDict.CONNECTED\n  | NamesDict.DISCONNECTED;\n\nexport interface ConnectionManagerEventMap {\n  [NamesDict.CONNECTING]: ISFSocketEvent,\n  [NamesDict.DISCONNECTED]: undefined,\n  [NamesDict.CONNECTED]: undefined,\n  [NamesDict.CHANNEL_JOINED]: string[],\n  [NamesDict.CHANNEL_JOIN_FAILED]: string[],\n  [NamesDict.CHANNEL_LEFT]: string[],\n  [NamesDict.ERROR]: ISFSocketEvent,\n  [NamesDict.MESSAGE]: ISFSocketEvent,\n  [NamesDict.CLOSED]: ISFSocketEvent,\n  [NamesDict.UNAVAILABLE]: undefined,\n}\n\nexport default class ConnectionManager extends EventsDispatcher<ConnectionManagerEventMap> {\n  private options: ISFSocketConfig;\n\n  state: ConnectionState;\n\n  private connection: Connection | null;\n\n  private unavailableTimer: NodeJS.Timeout | null;\n\n  private retryTimer: NodeJS.Timeout | null;\n\n  private retryState: unknown;\n\n  private transport: ITransport;\n\n  private runner: IRunner | null;\n\n  private errorCallbacks: IErrorCallbacks;\n\n  private connectionCallbacks: IConnectionCallbacks;\n\n  constructor(options: ISFSocketConfig) {\n    super();\n    this.options = { ...defaultConfig, ...options };\n    this.state = 'initialized';\n    this.connection = null;\n\n    this.errorCallbacks = this.buildErrorCallbacks();\n    this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);\n\n    this.transport = new Transport(\n      'ws',\n      options,\n    );\n    this.runner = null;\n\n    this.unavailableTimer = null;\n    this.retryTimer = null;\n  }\n\n  connect() {\n    if (this.connection || this.runner) {\n      return;\n    }\n    this.updateState(NamesDict.CONNECTING);\n    this.startConnecting();\n    this.setUnavailableTimer();\n  }\n\n  send(data: string) {\n    if (this.connection) {\n      return this.connection.send(data);\n    }\n    return false;\n  }\n\n  sendCommand(name: string, data: any) {\n    if (this.connection) {\n      return this.connection.sendCommand(name, data);\n    }\n    return false;\n  }\n\n  sendJoin(channels: string[]) {\n    if (this.connection) {\n      this.connection.sendJoin(channels);\n    }\n    return false;\n  }\n\n  sendLeave(channels: string[]) {\n    if (this.connection) {\n      this.connection.sendLeave(channels);\n    }\n    return false;\n  }\n\n  disconnect() {\n    this.disconnectInternally();\n    this.updateState(NamesDict.DISCONNECTED);\n  }\n\n  public isConnected() {\n    return this.state === NamesDict.CONNECTED;\n  }\n\n  private startConnecting() {\n    const callback: UndescribedCallbackFunction = async (closeEvent: ISFSocketEvent | undefined, connection: Connection) => { // TODO\n      if (closeEvent) {\n        this.abandonConnection();\n        if (await this.shouldRetry(closeEvent)) {\n          this.retryIn(this.options.retryTimeout || 0);\n        }\n        this.emit(NamesDict.CLOSED, closeEvent);\n      } else {\n        this.abortConnecting();\n\n        this.clearUnavailableTimer();\n        this.setConnection(connection);\n        this.updateState(NamesDict.CONNECTED);\n      }\n    };\n    this.runner = this.transport.connect(callback);\n  }\n\n  private abortConnecting() {\n    if (this.runner) {\n      this.runner.abort();\n      this.runner = null;\n    }\n  }\n\n  private disconnectInternally() {\n    this.abortConnecting();\n    this.clearRetryTimer();\n    this.clearUnavailableTimer();\n    if (this.connection) {\n      const connection = this.abandonConnection();\n      if (connection) connection.close();\n    }\n  }\n\n  private retryIn(delay: number) {\n    if (delay > 0) {\n      this.emit(NamesDict.CONNECTING, {\n        type: SFSocketEventType.CONNECTING,\n        data: String(Math.round(delay / 1000)),\n        error: null,\n      });\n    }\n    this.retryTimer = setTimeout(() => {\n      this.disconnectInternally();\n      this.connect();\n    }, delay || 0);\n  }\n\n  private clearRetryTimer() {\n    if (this.retryTimer !== null) {\n      clearTimeout(this.retryTimer);\n    }\n    this.retryTimer = null;\n  }\n\n  private setUnavailableTimer() {\n    this.unavailableTimer = setTimeout(\n      () => {\n        this.updateState(NamesDict.UNAVAILABLE);\n      },\n      this.options.unavailableTimeout,\n    );\n  }\n\n  private clearUnavailableTimer() {\n    if (this.unavailableTimer !== null) {\n      clearTimeout(this.unavailableTimer);\n    }\n    this.unavailableTimer = null;\n  }\n\n  private buildConnectionCallbacks(errorCallbacks: IErrorCallbacks): IConnectionCallbacks {\n    return {\n      ...errorCallbacks,\n      message: (socketEvent: ISFSocketEvent) => {\n        // includes pong messages from server\n        this.emit(NamesDict.MESSAGE, socketEvent);\n      },\n      error: (errorEvent: ISFSocketEvent) => {\n        // just emit error to user - socket will already be closed by browser\n        this.emit(NamesDict.ERROR, errorEvent);\n      },\n      closed: async (closeEvent: ISFSocketEvent) => {\n        this.abandonConnection();\n        if (await this.shouldRetry(closeEvent)) {\n          this.retryIn(this.options.retryTimeout || 0);\n        }\n        this.emit(NamesDict.CLOSED, closeEvent);\n      },\n      channelJoined: ((channels) => this.emit(NamesDict.CHANNEL_JOINED, channels)),\n      channelJoinFailed: ((channels) => this.emit(NamesDict.CHANNEL_JOIN_FAILED, channels)),\n      channelLeft: ((channels) => this.emit(NamesDict.CHANNEL_LEFT, channels)),\n    };\n  }\n\n  private buildErrorCallbacks(): IErrorCallbacks {\n    const withErrorEmitted = (callback: UndescribedCallbackFunction) => (result: IAction) => {\n      if (result.error) {\n        this.emit(NamesDict.ERROR, {\n          type: SFSocketEventType.ERROR,\n          data: null,\n          error: result.error,\n        });\n      }\n      callback(result);\n    };\n\n    return {\n      refused: withErrorEmitted(() => {\n        this.disconnect();\n      }),\n      unavailable: withErrorEmitted(() => {\n        this.retryIn(1000);\n      }),\n    };\n  }\n\n  private setConnection(connection: Connection | null) {\n    this.connection = connection;\n    if (!this.connection) {\n      return;\n    }\n    this.connection.bind(NamesDict.MESSAGE, this.connectionCallbacks.message);\n    this.connection.bind(NamesDict.CHANNEL_LEFT, this.connectionCallbacks.channelLeft);\n    this.connection.bind(NamesDict.CHANNEL_JOIN_FAILED, this.connectionCallbacks.channelJoinFailed);\n    this.connection.bind(NamesDict.CHANNEL_JOINED, this.connectionCallbacks.channelJoined);\n    this.connection.bind(NamesDict.ERROR, this.connectionCallbacks.error);\n    this.connection.bind(NamesDict.CLOSED, this.connectionCallbacks.closed);\n\n    this.retryState = undefined;\n  }\n\n  private abandonConnection() {\n    if (!this.connection) {\n      return null;\n    }\n    this.connection.unbind(NamesDict.MESSAGE, this.connectionCallbacks.message);\n    this.connection.unbind(NamesDict.CHANNEL_LEFT, this.connectionCallbacks.channelLeft);\n    this.connection.unbind(NamesDict.CHANNEL_JOIN_FAILED, this.connectionCallbacks.channelJoinFailed);\n    this.connection.unbind(NamesDict.CHANNEL_JOINED, this.connectionCallbacks.channelJoined);\n    this.connection.unbind(NamesDict.ERROR, this.connectionCallbacks.error);\n    this.connection.unbind(NamesDict.CLOSED, this.connectionCallbacks.closed);\n\n    const { connection } = this;\n    this.connection = null;\n\n    return connection;\n  }\n\n  private updateState(newState: NamesDict.UNAVAILABLE\n    | NamesDict.CONNECTING\n    | NamesDict.CONNECTED\n    | NamesDict.DISCONNECTED) {\n    const previousState = this.state;\n    this.state = newState;\n    if (previousState !== newState) {\n      this.emit(newState, undefined);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  private async shouldRetry(closeEvent: ISFSocketEvent): Promise<boolean> {\n    if (this.options.retryStrategy) {\n      const { retry, state } = await this.options.retryStrategy(closeEvent, this.retryState);\n      if (retry) {\n        this.retryState = state;\n      } else {\n        this.retryState = undefined;\n      }\n      return retry;\n    }\n    return false;\n  }\n}\n","import {\n  SFSocket,\n  ISFSocketEvent,\n  ISFSocketConfig,\n  SFSocketEventType,\n} from './SFSocket';\n\nimport { NamesDict, NamesDict as eventNames } from './eventdispatcher/events';\nimport Channel, { ChannelStatus } from './Channel';\nimport {\n  ICallback, ICallbackTable, SFEventMap, UEventCallback, UndescribedCallbackFunction,\n} from './types';\n\nconst makeSocketOptions = (wsUrl: string) => {\n  const url = new URL(wsUrl);\n  const urlProtocol = url.protocol ? url.protocol.replace(':', '') : null;\n\n  if (url.hostname && url.port && urlProtocol) {\n    return {\n      host: url.hostname, // host: 'localhost',\n      port: url.port, // port: '8080',\n      path: urlProtocol, // path: 'ws',\n    };\n  }\n\n  return null;\n};\n\nexport {\n  SFSocket,\n  makeSocketOptions,\n  eventNames,\n  Channel,\n  ChannelStatus,\n  ICallback,\n  ICallbackTable,\n  ISFSocketEvent,\n  NamesDict,\n  ISFSocketConfig,\n  SFSocketEventType,\n  SFEventMap,\n  UEventCallback,\n  UndescribedCallbackFunction,\n};\n"],"sourceRoot":""}