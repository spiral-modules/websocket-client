!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.SFSocket=n():t.SFSocket=n()}(window,(function(){return function(t){var n={};function e(i){if(n[i])return n[i].exports;var s=n[i]={i:i,l:!1,exports:{}};return t[i].call(s.exports,s,s.exports,e),s.l=!0,s.exports}return e.m=t,e.c=n,e.d=function(t,n,i){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:i})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(e.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var s in t)e.d(i,s,function(n){return t[n]}.bind(null,s));return i},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=0)}([function(t,n,e){"use strict";var i;function s(t,n,e){let i=e.value;if("function"!=typeof i)throw new TypeError(`@autobind decorator can only be applied to methods not: ${typeof i}`);let s=!1;return{configurable:!0,get(){if(s||this===t.prototype||this.hasOwnProperty(n)||"function"!=typeof i)return i;const e=i.bind(this);return s=!0,Object.defineProperty(this,n,{configurable:!0,get:()=>e,set(t){i=t,delete this[n]}}),s=!1,e},set(t){i=t}}}e.r(n),e.d(n,"SFSocket",(function(){return S})),e.d(n,"makeSocketOptions",(function(){return v})),e.d(n,"eventNames",(function(){return i})),e.d(n,"Channel",(function(){return a})),e.d(n,"ChannelStatus",(function(){return o})),e.d(n,"NamesDict",(function(){return i})),e.d(n,"SFSocketEventType",(function(){return O})),function(t){t.CONNECTED="connected",t.MESSAGE="message",t.CONNECTING="connecting",t.DISCONNECTED="disconnected",t.ERROR="error",t.OPEN="open",t.INITIALIZED="initialized",t.CLOSED="closed",t.UNAVAILABLE="unavailable",t.CHANNEL_JOINED="channel_joined",t.CHANNEL_JOIN_FAILED="channel_join_failed",t.CHANNEL_LEFT="channel_left"}(i||(i={}));var o,r=function(t,n,e,i){var s,o=arguments.length,r=o<3?n:null===i?i=Object.getOwnPropertyDescriptor(n,e):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(t,n,e,i);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(r=(o<3?s(r):o>3?s(n,e,r):s(n,e))||r);return o>3&&r&&Object.defineProperty(n,e,r),r};!function(t){t.CLOSED="closed",t.JOINING="joining",t.JOINED="joined",t.LEAVING="leaving",t.ERROR="error"}(o||(o={}));class a{constructor(t,n){this.channelStatus=o.CLOSED,this.selfName=t,this.socket=n,this.cMgr=n.cMgr,this.enabled=!1}get status(){return this.channelStatus}get name(){return this.selfName}get isActive(){return this.cMgr.isConnected()&&this.channelStatus===o.JOINED}join(){this.enabled||(this.enabled=!0,this.startListening(),this.cMgr.isConnected()&&this.sendJoinCommand())}subscribe(t,n){this.cMgr.bind(t,n,this.name)}unsubscribe(t,n){this.cMgr.unbind(t,n,this.name)}leave(){this.enabled&&(this.enabled=!1,this.channelStatus=o.LEAVING,this.cMgr.isConnected()&&this.cMgr.sendLeave([this.name]),this.stopListening())}onConnect(){this.enabled&&this.sendJoinCommand()}onDisconnect(){this.channelStatus=o.CLOSED}onJoin(t){t.indexOf(this.name)>=0&&(this.channelStatus=o.JOINED)}onLeft(t){t.indexOf(this.name)>=0&&(this.channelStatus=o.CLOSED)}onJoinFailed(t){t.indexOf(this.name)>=0&&(this.channelStatus=o.ERROR)}sendJoinCommand(){this.channelStatus!==o.JOINING&&(this.channelStatus=o.JOINING,this.cMgr.sendJoin([this.name]))}startListening(){this.cMgr.bind(i.DISCONNECTED,this.onDisconnect),this.cMgr.bind(i.CHANNEL_JOIN_FAILED,this.onJoinFailed),this.cMgr.bind(i.CHANNEL_JOINED,this.onJoin),this.cMgr.bind(i.CHANNEL_LEFT,this.onLeft),this.cMgr.bind(i.CONNECTED,this.onConnect)}stopListening(){this.cMgr.unbind(i.DISCONNECTED,this.onDisconnect),this.cMgr.unbind(i.CHANNEL_JOIN_FAILED,this.onJoinFailed),this.cMgr.unbind(i.CHANNEL_JOINED,this.onJoin),this.cMgr.unbind(i.CHANNEL_LEFT,this.onLeft),this.cMgr.unbind(i.CONNECTED,this.onConnect)}}r([s],a.prototype,"onConnect",null),r([s],a.prototype,"onDisconnect",null),r([s],a.prototype,"onJoin",null),r([s],a.prototype,"onLeft",null),r([s],a.prototype,"onJoinFailed",null);var c=function(t,n,e,i){return new(e||(e=Promise))((function(s,o){function r(t){try{c(i.next(t))}catch(t){o(t)}}function a(t){try{c(i.throw(t))}catch(t){o(t)}}function c(t){var n;t.done?s(t.value):(n=t.value,n instanceof e?n:new e((function(t){t(n)}))).then(r,a)}c((i=i.apply(t,n||[])).next())}))};const l={host:"",port:80,path:"",unavailableTimeout:1e4,retryTimeout:10,useTLS:!1,retryStrategy:(h={retries:3,delay:1e3,multiplier:5},(t,n)=>c(void 0,void 0,void 0,(function*(){var t,e,i,s;const o=n;if(-1===h.retries)return Promise.resolve({retry:!0,state:void 0});if(0===h.retries)return Promise.resolve({retry:!1,state:void 0});const r=null!==(t=h.multiplier)&&void 0!==t?t:1,a=null!==(e=h.retries)&&void 0!==e?e:1,l=null!==(i=null==o?void 0:o.retry)&&void 0!==i?i:0,d=(null==o?void 0:o.delay)?o.delay*r:null!==(s=h.delay)&&void 0!==s?s:0;return l<a?(yield(u=d,c(void 0,void 0,void 0,(function*(){return new Promise(t=>{setTimeout(t,u)})}))),Promise.resolve({retry:!0,state:{delay:d,retry:l+1}})):Promise.resolve({retry:!0,state:void 0});var u})))};var h;class d{constructor(){this.callbacks={}}get(t){return this.callbacks[t]||[]}add(t,n,e){this.callbacks[t]||(this.callbacks[t]=[]),this.callbacks[t].push({fn:n,channel:e||null})}remove(t,n,e){if(!t&&!n&&!e)return void(this.callbacks={});const i=t?[t]:Object.keys(this.callbacks);n||e?this.removeCallback(i,n,e):this.removeAllCallbacks(i)}removeCallback(t,n,e){t.forEach(t=>{const i=this.callbacks[t]||[];this.callbacks[t]=i.filter(t=>{const i=n&&n===t.fn,s=e&&e===t.channel;return!i&&!s})})}removeAllCallbacks(t){t.forEach(t=>{delete this.callbacks[t]})}}class u{constructor(){this.callbacks=new d}bind(t,n,e){return this.callbacks.add(t,n,e),this}unbind(t,n,e){return this.callbacks.remove(t,n,e),this}emit(t,n){const e=this.callbacks.get(t),i=(s=n)&&s.context&&"string"==typeof s.context.channel?n.context.channel:null;var s;return e&&e.length>0&&e.forEach(t=>{const e=t.channel===i;(!t.channel||!i||e)&&t.fn(n)}),this}}var E;!function(t){t.CHANNEL_JOINED="@join",t.CHANNEL_JOIN_FAILED="#join",t.CHANNEL_LEFT="@leave",t.CHANNEL_LEAVE_FAILED="#leave"}(E||(E={}));const N=new Set([E.CHANNEL_JOINED,E.CHANNEL_JOIN_FAILED,E.CHANNEL_LEFT,E.CHANNEL_LEAVE_FAILED]),b=t=>{const n={command:t.type,topics:t.payload};return JSON.stringify(n)};var C;!function(t){t.JOIN="join",t.LEAVE="leave"}(C||(C={}));const p=new Set([C.JOIN,C.LEAVE]);class f extends u{constructor(t,n){super(),this.id=t,this.transport=n,this.bindListeners()}send(t){return!!this.transport&&this.transport.send(t)}sendCommand(t,n){if(p.has(t))throw new Error(`${t} is a reserved command, cant be sent manually`);return this.send(b({type:t,payload:n}))}sendJoin(t){this.send(b({type:C.JOIN,payload:t}))}sendLeave(t){this.send(b({type:C.LEAVE,payload:t}))}close(){this.transport&&this.transport.close()}bindListeners(){const t=t=>{this.transport&&(this.transport.unbind(i.MESSAGE,t.message),this.transport.unbind(i.ERROR,t.error),this.transport.unbind(i.CLOSED,t.closed))},n={message:t=>{let n=null;try{n=(t=>{if(t){const n=JSON.parse(t);if(N.has(n.topic)&&!n.payload&&Array.isArray(n.payload))return{type:O.ERROR,error:"WS event system event payload is invalid. Should be a string array",data:"MessageParseError"};switch(n.topic){case E.CHANNEL_JOINED:return{type:O.CHANNEL_JOINED,error:null,data:n.payload};case E.CHANNEL_JOIN_FAILED:return{type:O.CHANNEL_JOIN_FAILED,error:null,data:n.payload};case E.CHANNEL_LEFT:return{type:O.CHANNEL_LEFT,error:null,data:n.payload};case E.CHANNEL_LEAVE_FAILED:return{type:O.CHANNEL_LEAVE_FAILED,error:null,data:n.payload};default:return{type:O.MESSAGE,error:null,data:n.payload||null,context:Object.assign({},n.topic?{channel:n.topic}:{})}}}return{type:O.ERROR,error:"MessageEvent has no data property",data:"MessageParseError"}})(t.data)}catch(n){this.emit(i.ERROR,{type:O.ERROR,error:n.toString(),data:JSON.stringify(t)})}if(n)switch(n.type){case O.ERROR:this.emit(i.ERROR,n);break;case O.CHANNEL_JOIN_FAILED:this.emit(i.CHANNEL_JOIN_FAILED,n.data);break;case O.CHANNEL_JOINED:this.emit(i.CHANNEL_JOINED,n.data);break;case O.CHANNEL_LEFT:this.emit(i.CHANNEL_LEFT,n.data);break;case O.CHANNEL_LEAVE_FAILED:this.emit(i.ERROR,n);break;default:this.emit(i.MESSAGE,n)}},error:t=>{this.emit(i.ERROR,Object.assign(Object.assign({},t),{type:O.ERROR,data:null}))},closed:e=>{var s;t(n),(s=e).context&&void 0!==s.context.code&&this.handleCloseEvent(e),this.transport=null,this.emit(i.CLOSED,e)}};this.transport&&(this.transport.bind(i.MESSAGE,n.message),this.transport.bind(i.ERROR,n.error),this.transport.bind(i.CLOSED,n.closed))}handleCloseEvent(t){const n=(t=>t.context&&t.context.code?t.context.code<4e3&&t.context.code>=1002&&t.context.code<=1004?Object.assign(Object.assign({},t),{error:"Socket is unavailable"}):t:(console.error("Socket event do not contain close code"),Object.assign(Object.assign({},t),{error:"Connection refused"})))(t);n.type===O.CLOSED?this.emit(i.CLOSED,n):this.emit(i.ERROR,n)}}class y extends u{constructor(t,n){super(),this.initialize=()=>{const t=this;t.hooks.isInitialized()?t.changeState(i.INITIALIZED):t.onClose()},this.hooks=t,this.name=n,this.state="new"}connect(){if(this.socket||"initialized"!==this.state)return!1;const{url:t}=this.hooks;try{this.socket=this.hooks.getSocket(t)}catch(t){return setTimeout(()=>{this.onError(t),this.onClosed({type:O.ERROR,data:t,error:t.toString(),context:{code:0}})}),!1}return this.bindListeners(),this.changeState(i.CONNECTING),!0}close(){return!!this.socket&&(this.socket.close(),!0)}send(t){return"open"===this.state&&(setTimeout(()=>{this.socket&&this.socket.send(t)}),!0)}unbindListeners(){this.socket&&(this.socket.onopen=null,this.socket.onerror=null,this.socket.onclose=null,this.socket.onmessage=null)}onOpen(){this.changeState(i.OPEN),this.socket&&(this.socket.onopen=null)}onError(t){var n;(n=t)&&"string"==typeof n.type&&void 0!==n.currentTarget?this.emit(i.ERROR,{type:O.ERROR,error:"Websocket connection error",data:null}):this.emit(i.ERROR,{type:O.ERROR,error:t?t.message:"Websocket connection error",data:t?t.name:null})}onClose(t){t?this.onClosed({type:t.wasClean?O.CLOSED:O.ERROR,data:t.wasClean?t.reason:null,error:t.wasClean?null:t.reason,context:{code:t.code}}):this.onClosed({type:O.ERROR,data:null,error:"Closed for unknown reason",context:{code:0}}),this.unbindListeners(),this.socket=void 0}onMessage(t){this.emit(i.MESSAGE,{type:O.MESSAGE,data:"string"==typeof t.data?t.data:JSON.stringify(t.data),error:null})}bindListeners(){this.socket&&(this.socket.onopen=()=>{this.onOpen()},this.socket.onerror=t=>{this.onError(t)},this.socket.onclose=t=>{this.onClose(t)},this.socket.onmessage=t=>{this.onMessage(t)})}changeState(t){this.state=t,this.emit(t,void 0)}onClosed(t){this.state=i.CLOSED,this.emit(i.CLOSED,t)}}class L{constructor(t,n){this.options=n||{};const e=`ws${n.useTLS?"s":""}`,i=`${n.host}:${n.port}`,s=n.queryParams?Object.entries(n.queryParams).map(([t,n])=>`${encodeURIComponent(t)}=${encodeURIComponent(n)}`).join("&"):null,o=`${e}://${i}/${n.path}${s?`?${s}`:""}`;this.hooks={url:o,isInitialized:()=>!!window.WebSocket,getSocket:t=>new WebSocket(t)},this.name=t}connect(t){let n=!1;const e=new y(this.hooks,this.name),s=()=>{e.unbind(i.INITIALIZED,s),e.connect()},o=()=>{e.unbind(i.INITIALIZED,s),e.unbind(i.OPEN,r),e.unbind(i.ERROR,a),e.unbind(i.CLOSED,c)},r=()=>{n=!0,o();const i=new f("",e);t(null,i)},a=()=>{},c=n=>{o(),t(n)};return e.bind(i.INITIALIZED,s),e.bind(i.OPEN,r),e.bind(i.ERROR,a),e.bind(i.CLOSED,c),e.initialize(),{abort:()=>{n||(o(),e.close())}}}}var O,m=function(t,n,e,i){return new(e||(e=Promise))((function(s,o){function r(t){try{c(i.next(t))}catch(t){o(t)}}function a(t){try{c(i.throw(t))}catch(t){o(t)}}function c(t){var n;t.done?s(t.value):(n=t.value,n instanceof e?n:new e((function(t){t(n)}))).then(r,a)}c((i=i.apply(t,n||[])).next())}))};class g extends u{constructor(t){super(),this.options=Object.assign(Object.assign({},l),t),this.state="initialized",this.connection=null,this.errorCallbacks=this.buildErrorCallbacks(),this.connectionCallbacks=this.buildConnectionCallbacks(this.errorCallbacks),this.transport=new L("ws",t),this.runner=null,this.unavailableTimer=null,this.retryTimer=null}connect(){this.connection||this.runner||(this.updateState(i.CONNECTING),this.startConnecting(),this.setUnavailableTimer())}send(t){return!!this.connection&&this.connection.send(t)}sendCommand(t,n){return!!this.connection&&this.connection.sendCommand(t,n)}sendJoin(t){return this.connection&&this.connection.sendJoin(t),!1}sendLeave(t){return this.connection&&this.connection.sendLeave(t),!1}disconnect(){this.disconnectInternally(),this.updateState(i.DISCONNECTED)}isConnected(){return this.state===i.CONNECTED}startConnecting(){this.runner=this.transport.connect((t,n)=>m(this,void 0,void 0,(function*(){t?(this.abandonConnection(),(yield this.shouldRetry(t))&&this.retryIn(this.options.retryTimeout||0),this.emit(i.CLOSED,t)):(this.abortConnecting(),this.clearUnavailableTimer(),this.setConnection(n),this.updateState(i.CONNECTED))})))}abortConnecting(){this.runner&&(this.runner.abort(),this.runner=null)}disconnectInternally(){if(this.abortConnecting(),this.clearRetryTimer(),this.clearUnavailableTimer(),this.connection){const t=this.abandonConnection();t&&t.close()}}retryIn(t){t>0&&this.emit(i.CONNECTING,{type:O.CONNECTING,data:String(Math.round(t/1e3)),error:null}),this.retryTimer=setTimeout(()=>{this.disconnectInternally(),this.connect()},t||0)}clearRetryTimer(){null!==this.retryTimer&&clearTimeout(this.retryTimer),this.retryTimer=null}setUnavailableTimer(){this.unavailableTimer=setTimeout(()=>{this.updateState(i.UNAVAILABLE)},this.options.unavailableTimeout)}clearUnavailableTimer(){null!==this.unavailableTimer&&clearTimeout(this.unavailableTimer),this.unavailableTimer=null}buildConnectionCallbacks(t){return Object.assign(Object.assign({},t),{message:t=>{this.emit(i.MESSAGE,t)},error:t=>{this.emit(i.ERROR,t)},closed:t=>m(this,void 0,void 0,(function*(){this.abandonConnection(),(yield this.shouldRetry(t))&&this.retryIn(this.options.retryTimeout||0),this.emit(i.CLOSED,t)})),channelJoined:t=>this.emit(i.CHANNEL_JOINED,t),channelJoinFailed:t=>this.emit(i.CHANNEL_JOIN_FAILED,t),channelLeft:t=>this.emit(i.CHANNEL_LEFT,t)})}buildErrorCallbacks(){const t=t=>n=>{n.error&&this.emit(i.ERROR,{type:O.ERROR,data:null,error:n.error}),t(n)};return{refused:t(()=>{this.disconnect()}),unavailable:t(()=>{this.retryIn(1e3)})}}setConnection(t){this.connection=t,this.connection&&(this.connection.bind(i.MESSAGE,this.connectionCallbacks.message),this.connection.bind(i.CHANNEL_LEFT,this.connectionCallbacks.channelLeft),this.connection.bind(i.CHANNEL_JOIN_FAILED,this.connectionCallbacks.channelJoinFailed),this.connection.bind(i.CHANNEL_JOINED,this.connectionCallbacks.channelJoined),this.connection.bind(i.ERROR,this.connectionCallbacks.error),this.connection.bind(i.CLOSED,this.connectionCallbacks.closed),this.retryState=void 0)}abandonConnection(){if(!this.connection)return null;this.connection.unbind(i.MESSAGE,this.connectionCallbacks.message),this.connection.unbind(i.CHANNEL_LEFT,this.connectionCallbacks.channelLeft),this.connection.unbind(i.CHANNEL_JOIN_FAILED,this.connectionCallbacks.channelJoinFailed),this.connection.unbind(i.CHANNEL_JOINED,this.connectionCallbacks.channelJoined),this.connection.unbind(i.ERROR,this.connectionCallbacks.error),this.connection.unbind(i.CLOSED,this.connectionCallbacks.closed);const{connection:t}=this;return this.connection=null,t}updateState(t){const n=this.state;this.state=t,n!==t&&this.emit(t,void 0)}shouldRetry(t){return m(this,void 0,void 0,(function*(){if(this.options.retryStrategy){const{retry:n,state:e}=yield this.options.retryStrategy(t,this.retryState);return this.retryState=n?e:void 0,n}return!1}))}}!function(t){t.CONNECTING="sfSocket:connecting",t.MESSAGE="sfSocket:message",t.CHANNEL_JOINED="channel_joined",t.CHANNEL_JOIN_FAILED="channel_join_failed",t.CHANNEL_LEFT="channel_left",t.CHANNEL_LEAVE_FAILED="channel_leave_failed",t.ERROR="sfSocket:error",t.CLOSED="sfSocket:closed"}(O||(O={}));class S{constructor(t){if(this.channels={},!t||"object"!=typeof t)throw new Error("sfSocket options should be an object");const n=t||{};this.config=Object.assign(Object.assign({},l),n),this.config.port=n.useTLS?443:80,n.port&&(this.config.port=n.port),this.cMgr=new g(this.config),this.cMgr.bind(i.CONNECTED,()=>{Object.values(this.channels).forEach(t=>{t.join()})}),this.cMgr.bind(i.ERROR,t=>{console.error(t)}),S.instances.push(this),S.isReady&&this.connect()}static ready(){S.isReady=!0,S.instances.forEach(t=>{t.connect()})}connect(){this.cMgr.connect()}disconnect(){this.cMgr.disconnect()}sendCommand(t,n){return this.cMgr.sendCommand(t,n)}joinChannelList(t){t.forEach(t=>{this.joinChannel(t)})}leaveChannelList(t){t.forEach(t=>{this.leaveChannel(t)})}subscribe(t,n,e){return this.cMgr.bind(t,n,e)}unsubscribe(t,n,e){return this.cMgr.unbind(t,n,e)}joinChannel(t,n=!1){if(this.channels[t])throw new Error(`Channel ${t} already exists`);return this.channels[t]=new a(t,this),n||this.channels[t].join(),this.channels[t]}leaveChannel(t){if(!this.channels[t])throw new Error(`Channel ${t} does not exist`);const n=this.channels[t];return n.leave(),delete this.channels[t],n}getChannel(t){return this.channels[t]}}S.instances=[],S.isReady=!1;const v=t=>{const n=new URL(t),e=n.protocol?n.protocol.replace(":",""):null;return n.hostname&&n.port&&e?{host:n.hostname,port:n.port,path:e}:null}}])}));
//# sourceMappingURL=socket.js.map